USE [master]
GO
/****** Object:  Database [FORDATA_{1}]    Script Date: 03/19/2014 09:13:47 ******/
CREATE DATABASE [FORDATA_{1}] ON  PRIMARY 
( NAME = N'FORDATA_{1}_DAT', FILENAME = N'{0}FORDATA_{1}.mdf' , SIZE = 87296KB , MAXSIZE = UNLIMITED, FILEGROWTH = 10%)
 LOG ON 
( NAME = N'FORDATA_{1}_LOG', FILENAME = N'{0}FORDATA_{1}_log.LDF' , SIZE = 92864KB , MAXSIZE = UNLIMITED, FILEGROWTH = 10%)
GO
ALTER DATABASE [FORDATA_{1}] SET COMPATIBILITY_LEVEL = 100
GO
IF (1 = FULLTEXTSERVICEPROPERTY('IsFullTextInstalled'))
begin
EXEC [FORDATA_{1}].[dbo].[sp_fulltext_database] @action = 'enable'
end
GO
ALTER DATABASE [FORDATA_{1}] SET ANSI_NULL_DEFAULT OFF
GO
ALTER DATABASE [FORDATA_{1}] SET ANSI_NULLS OFF
GO
ALTER DATABASE [FORDATA_{1}] SET ANSI_PADDING OFF
GO
ALTER DATABASE [FORDATA_{1}] SET ANSI_WARNINGS OFF
GO
ALTER DATABASE [FORDATA_{1}] SET ARITHABORT OFF
GO
ALTER DATABASE [FORDATA_{1}] SET AUTO_CLOSE ON
GO
ALTER DATABASE [FORDATA_{1}] SET AUTO_CREATE_STATISTICS ON
GO
ALTER DATABASE [FORDATA_{1}] SET AUTO_SHRINK OFF
GO
ALTER DATABASE [FORDATA_{1}] SET AUTO_UPDATE_STATISTICS ON
GO
ALTER DATABASE [FORDATA_{1}] SET CURSOR_CLOSE_ON_COMMIT OFF
GO
ALTER DATABASE [FORDATA_{1}] SET CURSOR_DEFAULT  GLOBAL
GO
ALTER DATABASE [FORDATA_{1}] SET CONCAT_NULL_YIELDS_NULL OFF
GO
ALTER DATABASE [FORDATA_{1}] SET NUMERIC_ROUNDABORT OFF
GO
ALTER DATABASE [FORDATA_{1}] SET QUOTED_IDENTIFIER OFF
GO
ALTER DATABASE [FORDATA_{1}] SET RECURSIVE_TRIGGERS OFF
GO
ALTER DATABASE [FORDATA_{1}] SET  DISABLE_BROKER
GO
ALTER DATABASE [FORDATA_{1}] SET AUTO_UPDATE_STATISTICS_ASYNC OFF
GO
ALTER DATABASE [FORDATA_{1}] SET DATE_CORRELATION_OPTIMIZATION OFF
GO
ALTER DATABASE [FORDATA_{1}] SET TRUSTWORTHY OFF
GO
ALTER DATABASE [FORDATA_{1}] SET ALLOW_SNAPSHOT_ISOLATION OFF
GO
ALTER DATABASE [FORDATA_{1}] SET PARAMETERIZATION SIMPLE
GO
ALTER DATABASE [FORDATA_{1}] SET READ_COMMITTED_SNAPSHOT OFF
GO
ALTER DATABASE [FORDATA_{1}] SET HONOR_BROKER_PRIORITY OFF
GO
ALTER DATABASE [FORDATA_{1}] SET  READ_WRITE
GO
ALTER DATABASE [FORDATA_{1}] SET RECOVERY SIMPLE
GO
ALTER DATABASE [FORDATA_{1}] SET  MULTI_USER
GO
ALTER DATABASE [FORDATA_{1}] SET PAGE_VERIFY CHECKSUM
GO
ALTER DATABASE [FORDATA_{1}] SET DB_CHAINING OFF
GO
USE [FORDATA_{1}]
GO
/****** Object:  Table [dbo].[i10]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i10](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i10_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i11]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i11](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i11_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i12]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i12](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i12_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i13]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i13](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i13_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i14]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i14](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i14_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i15]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i15](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i15_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i16]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i16](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i16_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[GDB_TABLES_LAST_MODIFIED]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[GDB_TABLES_LAST_MODIFIED](
	[table_name] [nvarchar](160) NOT NULL,
	[last_modified_count] [int] NOT NULL
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [GDB_LMODIFIED_IX1] ON [dbo].[GDB_TABLES_LAST_MODIFIED] 
(
	[table_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_P_XIANG_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_P_XIANG_10K](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R53_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S17_idx] ON [dbo].[BASE_P_XIANG_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_P_XIAN_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_P_XIAN_10K](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R54_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S18_idx] ON [dbo].[BASE_P_XIAN_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_P_WATER_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_P_WATER_10K](
	[OBJECTID] [int] NOT NULL,
	[NAME] [nvarchar](30) NOT NULL,
	[TYPE] [nvarchar](1) NOT NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R52_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S16_idx] ON [dbo].[BASE_P_WATER_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_P_LINBAN_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_P_LINBAN_10K](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R51_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S15_idx] ON [dbo].[BASE_P_LINBAN_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_P_CUN_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_P_CUN_10K](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R55_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S19_idx] ON [dbo].[BASE_P_CUN_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_L_XIANG_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_L_XIANG_10K](
	[OBJECTID] [int] NOT NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R56_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S20_idx] ON [dbo].[BASE_L_XIANG_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_L_XIAN_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_L_XIAN_10K](
	[OBJECTID] [int] NOT NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R57_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S21_idx] ON [dbo].[BASE_L_XIAN_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_L_ROAD_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_L_ROAD_10K](
	[OBJECTID] [int] NOT NULL,
	[NAME] [nvarchar](30) NULL,
	[TYPE] [nvarchar](1) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R58_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S22_idx] ON [dbo].[BASE_L_ROAD_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_L_LINBAN_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_L_LINBAN_10K](
	[OBJECTID] [int] NOT NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R59_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S23_idx] ON [dbo].[BASE_L_LINBAN_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_L_CUN_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_L_CUN_10K](
	[OBJECTID] [int] NOT NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R60_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S24_idx] ON [dbo].[BASE_L_CUN_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[BASE_D_RESIDENT_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[BASE_D_RESIDENT_10K](
	[OBJECTID] [int] NOT NULL,
	[CODE] [nvarchar](12) NULL,
	[NAME] [nvarchar](50) NULL,
	[TYPE] [nvarchar](2) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R61_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S25_idx] ON [dbo].[BASE_D_RESIDENT_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[FOR_XIAOBAN_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[FOR_XIAOBAN_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_YE_JU] [nvarchar](6) NULL,
	[LIN_CHANG] [nvarchar](9) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[Q_SEN_LB] [nvarchar](3) NULL,
	[SEN_LIN_LB] [nvarchar](3) NULL,
	[G_CHENG_LB] [nvarchar](2) NULL,
	[SHI_QUAN_D] [nvarchar](2) NULL,
	[GJGYL_BHDJ] [nvarchar](1) NULL,
	[ZL_DJ] [nvarchar](1) NULL,
	[BH_DJ] [nvarchar](1) NULL,
	[LYFQ] [nvarchar](6) NULL,
	[QYKZ] [nvarchar](1) NULL,
	[BCLD] [nvarchar](1) NULL,
	[BHYY] [nvarchar](2) NULL,
	[BHND] [nvarchar](4) NULL,
	[DI_MAO] [nvarchar](1) NULL,
	[HBG] [int] NULL,
	[PO_XIANG] [nvarchar](1) NULL,
	[PO_WEI] [nvarchar](1) NULL,
	[PO_DU] [nvarchar](2) NULL,
	[TU_RANG_LX] [nvarchar](3) NULL,
	[TU_CENG_HD] [int] NULL,
	[KZLYH] [int] NULL,
	[FZCH] [int] NULL,
	[SLHL] [int] NULL,
	[CTMY] [nvarchar](1) NULL,
	[QSLX] [nvarchar](1) NULL,
	[QSCD] [nvarchar](1) NULL,
	[TD_TH_LX] [nvarchar](1) NULL,
	[GMYSZ] [nvarchar](6) NULL,
	[GMPJGD] [numeric](38, 1) NULL,
	[GMZGD] [numeric](38, 8) NULL,
	[CBYSZ] [nvarchar](6) NULL,
	[CBPJGD] [numeric](38, 1) NULL,
	[CBZGD] [numeric](38, 8) NULL,
	[GXYSSZ] [nvarchar](6) NULL,
	[GXPJNL] [int] NULL,
	[GXPJGD] [numeric](38, 1) NULL,
	[GXGQZS] [int] NULL,
	[GXFBQK] [nvarchar](1) NULL,
	[GXSZQK] [nvarchar](1) NULL,
	[DISPE] [nvarchar](2) NULL,
	[DISASTER_C] [nvarchar](1) NULL,
	[JKZK] [nvarchar](1) NULL,
	[SMHLX] [nvarchar](1) NULL,
	[SMHCD] [nvarchar](1) NULL,
	[SMHCY] [nvarchar](2) NULL,
	[SHLX] [nvarchar](3) NULL,
	[SHCD] [nvarchar](1) NULL,
	[SDLX] [nvarchar](2) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[JYLX] [nvarchar](2) NULL,
	[QLJG] [nvarchar](1) NULL,
	[ZRD] [nvarchar](1) NULL,
	[JYCSLX] [nvarchar](2) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[YSMG] [numeric](38, 1) NULL,
	[KE_JI_DU] [nvarchar](1) NULL,
	[JJLCQ] [nvarchar](1) NULL,
	[SSLX] [nvarchar](1) NULL,
	[SSZYSZ] [nvarchar](6) NULL,
	[SSZZS] [int] NULL,
	[SSPJXJ] [numeric](38, 1) NULL,
	[SSPJGD] [numeric](38, 1) NULL,
	[XZWZL] [nvarchar](2) NULL,
	[XZWCD] [numeric](38, 1) NULL,
	[XZWKD] [numeric](38, 1) NULL,
	[LD_KD] [numeric](38, 8) NULL,
	[LD_CD] [numeric](38, 8) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[CCLDJ] [nvarchar](1) NULL,
	[XJBDJ] [nvarchar](3) NULL,
	[PINGJUN_NL] [int] NULL,
	[PINGJUN_XJ] [numeric](38, 1) NULL,
	[PINGJUN_SG] [numeric](38, 1) NULL,
	[PINGJUN_DM] [numeric](38, 1) NULL,
	[MEI_GQ_ZS] [int] NULL,
	[BSSZ] [nvarchar](6) NULL,
	[BSSZQY] [nvarchar](2) NULL,
	[BSSZNL] [int] NULL,
	[BSSZSG] [numeric](38, 1) NULL,
	[BSSZPJXJ] [numeric](38, 1) NULL,
	[BSSZGQDM] [numeric](38, 1) NULL,
	[BSSZGQZS] [int] NULL,
	[QHFQBH] [nvarchar](4) NULL,
	[LDSYDW] [numeric](38, 8) NULL,
	[FRZLDW] [numeric](38, 8) NULL,
	[YXMJ] [numeric](38, 2) NULL,
	[XZWMJ] [numeric](38, 2) NULL,
	[ZXJ] [int] NULL,
	[SLXJ] [int] NULL,
	[YSSZXJ] [int] NULL,
	[BSSZXJ] [int] NULL,
	[SSXJ] [int] NULL,
	[HUO_LMGQXJ] [numeric](38, 2) NULL,
	[ZFNL] [int] NULL,
	[ZLND] [int] NULL,
	[LING_ZU] [nvarchar](1) NULL,
	[LJ] [nvarchar](3) NULL,
	[BAK1] [numeric](38, 8) NULL,
	[BAK2] [numeric](38, 8) NULL,
	[XBID] [nvarchar](30) NULL,
	[Remarks] [nvarchar](60) NULL,
	[GXSJ] [nvarchar](8) NULL,
	[Q_SQ_D] [nvarchar](2) NULL,
	[Q_GC_LB] [nvarchar](2) NULL,
	[STQW] [nvarchar](4) NULL,
	[Q_MJ] [numeric](38, 2) NULL,
	[Q_SZ] [nvarchar](6) NULL,
	[Q_YBD] [numeric](38, 2) NULL,
	[Q_PJNL] [smallint] NULL,
	[Q_PJXJ] [numeric](38, 1) NULL,
	[Q_PJSG] [numeric](38, 1) NULL,
	[Q_PJDM] [numeric](38, 1) NULL,
	[Q_ZXJ] [int] NULL,
	[Q_BSSZPJXJ] [numeric](38, 1) NULL,
	[Q_BSSZNL] [smallint] NULL,
	[Q_BSSZSG] [numeric](38, 1) NULL,
	[Q_BSSZGQDM] [numeric](38, 1) NULL,
	[Q_YSSZXJ] [int] NULL,
	[Q_BSSZXJ] [int] NULL,
	[Q_SSXJ] [int] NULL,
	[GX_SPARE1] [nvarchar](6) NULL,
	[GX_SPARE2] [nvarchar](12) NULL,
	[DT_SRC] [nvarchar](10) NULL,
	[V_TMMJ] [numeric](38, 2) NULL,
	[YDZL] [nvarchar](1) NULL,
	[KJD] [nvarchar](1) NULL,
	[GBHJZSL] [nvarchar](1) NULL,
	[JYGLLX] [nvarchar](1) NULL,
	[GLLX] [nvarchar](2) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R70_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S32_idx] ON [dbo].[FOR_XIAOBAN_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[FOR_XIAOBAN_{3}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[FOR_XIAOBAN_{3}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_YE_JU] [nvarchar](6) NULL,
	[LIN_CHANG] [nvarchar](9) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[Q_SEN_LB] [nvarchar](3) NULL,
	[SEN_LIN_LB] [nvarchar](3) NULL,
	[G_CHENG_LB] [nvarchar](2) NULL,
	[SHI_QUAN_D] [nvarchar](2) NULL,
	[GJGYL_BHDJ] [nvarchar](1) NULL,
	[ZL_DJ] [nvarchar](1) NULL,
	[BH_DJ] [nvarchar](1) NULL,
	[LYFQ] [nvarchar](6) NULL,
	[QYKZ] [nvarchar](1) NULL,
	[BCLD] [nvarchar](1) NULL,
	[BHYY] [nvarchar](2) NULL,
	[BHND] [nvarchar](4) NULL,
	[DI_MAO] [nvarchar](1) NULL,
	[HBG] [int] NULL,
	[PO_XIANG] [nvarchar](1) NULL,
	[PO_WEI] [nvarchar](1) NULL,
	[PO_DU] [nvarchar](2) NULL,
	[TU_RANG_LX] [nvarchar](3) NULL,
	[TU_CENG_HD] [int] NULL,
	[KZLYH] [int] NULL,
	[FZCH] [int] NULL,
	[SLHL] [int] NULL,
	[CTMY] [nvarchar](1) NULL,
	[QSLX] [nvarchar](1) NULL,
	[QSCD] [nvarchar](1) NULL,
	[TD_TH_LX] [nvarchar](1) NULL,
	[GMYSZ] [nvarchar](6) NULL,
	[GMPJGD] [numeric](38, 1) NULL,
	[GMZGD] [numeric](38, 8) NULL,
	[CBYSZ] [nvarchar](6) NULL,
	[CBPJGD] [numeric](38, 1) NULL,
	[CBZGD] [numeric](38, 8) NULL,
	[GXYSSZ] [nvarchar](6) NULL,
	[GXPJNL] [int] NULL,
	[GXPJGD] [numeric](38, 1) NULL,
	[GXGQZS] [int] NULL,
	[GXFBQK] [nvarchar](1) NULL,
	[GXSZQK] [nvarchar](1) NULL,
	[DISPE] [nvarchar](2) NULL,
	[DISASTER_C] [nvarchar](1) NULL,
	[JKZK] [nvarchar](1) NULL,
	[SMHLX] [nvarchar](1) NULL,
	[SMHCD] [nvarchar](1) NULL,
	[SMHCY] [nvarchar](2) NULL,
	[SHLX] [nvarchar](3) NULL,
	[SHCD] [nvarchar](1) NULL,
	[SDLX] [nvarchar](2) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[JYLX] [nvarchar](2) NULL,
	[QLJG] [nvarchar](1) NULL,
	[ZRD] [nvarchar](1) NULL,
	[JYCSLX] [nvarchar](2) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[YSMG] [numeric](38, 1) NULL,
	[KE_JI_DU] [nvarchar](1) NULL,
	[JJLCQ] [nvarchar](1) NULL,
	[SSLX] [nvarchar](1) NULL,
	[SSZYSZ] [nvarchar](6) NULL,
	[SSZZS] [int] NULL,
	[SSPJXJ] [numeric](38, 1) NULL,
	[SSPJGD] [numeric](38, 1) NULL,
	[XZWZL] [nvarchar](2) NULL,
	[XZWCD] [numeric](38, 1) NULL,
	[XZWKD] [numeric](38, 1) NULL,
	[LD_KD] [numeric](38, 8) NULL,
	[LD_CD] [numeric](38, 8) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[CCLDJ] [nvarchar](1) NULL,
	[XJBDJ] [nvarchar](3) NULL,
	[PINGJUN_NL] [int] NULL,
	[PINGJUN_XJ] [numeric](38, 1) NULL,
	[PINGJUN_SG] [numeric](38, 1) NULL,
	[PINGJUN_DM] [numeric](38, 1) NULL,
	[MEI_GQ_ZS] [int] NULL,
	[BSSZ] [nvarchar](6) NULL,
	[BSSZQY] [nvarchar](2) NULL,
	[BSSZNL] [int] NULL,
	[BSSZSG] [numeric](38, 1) NULL,
	[BSSZPJXJ] [numeric](38, 1) NULL,
	[BSSZGQDM] [numeric](38, 1) NULL,
	[BSSZGQZS] [int] NULL,
	[QHFQBH] [nvarchar](4) NULL,
	[LDSYDW] [numeric](38, 8) NULL,
	[FRZLDW] [numeric](38, 8) NULL,
	[YXMJ] [numeric](38, 2) NULL,
	[XZWMJ] [numeric](38, 2) NULL,
	[ZXJ] [int] NULL,
	[SLXJ] [int] NULL,
	[YSSZXJ] [int] NULL,
	[BSSZXJ] [int] NULL,
	[SSXJ] [int] NULL,
	[HUO_LMGQXJ] [numeric](38, 2) NULL,
	[ZFNL] [int] NULL,
	[ZLND] [int] NULL,
	[LING_ZU] [nvarchar](1) NULL,
	[LJ] [nvarchar](3) NULL,
	[BAK1] [numeric](38, 8) NULL,
	[BAK2] [numeric](38, 8) NULL,
	[XBID] [nvarchar](30) NULL,
	[Remarks] [nvarchar](60) NULL,
	[GXSJ] [nvarchar](8) NULL,
	[Q_SQ_D] [nvarchar](2) NULL,
	[Q_GC_LB] [nvarchar](2) NULL,
	[STQW] [nvarchar](4) NULL,
	[SHAPE] [geometry] NULL,
	[Q_MJ] [numeric](38, 2) NULL,
	[Q_SZ] [nvarchar](6) NULL,
	[Q_YBD] [numeric](38, 2) NULL,
	[Q_PJNL] [smallint] NULL,
	[Q_PJXJ] [numeric](38, 1) NULL,
	[Q_PJSG] [numeric](38, 1) NULL,
	[Q_PJDM] [numeric](38, 1) NULL,
	[Q_ZXJ] [int] NULL,
	[Q_BSSZPJXJ] [numeric](38, 1) NULL,
	[Q_BSSZNL] [smallint] NULL,
	[Q_BSSZSG] [numeric](38, 1) NULL,
	[Q_BSSZGQDM] [numeric](38, 1) NULL,
	[Q_YSSZXJ] [int] NULL,
	[Q_BSSZXJ] [int] NULL,
	[Q_SSXJ] [int] NULL,
	[GX_SPARE1] [nvarchar](6) NULL,
	[GX_SPARE2] [nvarchar](12) NULL,
	[DT_SRC] [nvarchar](10) NULL,
	[V_TMMJ] [numeric](38, 2) NULL,
	[YDZL] [varchar](1) NULL,
	[KJD] [nvarchar](1) NULL,
	[GBHJZSL] [nvarchar](1) NULL,
	[JYGLLX] [nvarchar](1) NULL,
	[GLLX] [nvarchar](2) NULL,
 CONSTRAINT [R48_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_PADDING ON
CREATE SPATIAL INDEX [S12_idx] ON [dbo].[FOR_XIAOBAN_{3}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[FOR_XBBH_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[FOR_XBBH_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_YE_JU] [nvarchar](6) NULL,
	[LIN_CHANG] [nvarchar](9) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[Q_SEN_LB] [nvarchar](3) NULL,
	[SEN_LIN_LB] [nvarchar](3) NULL,
	[G_CHENG_LB] [nvarchar](2) NULL,
	[SHI_QUAN_D] [nvarchar](2) NULL,
	[GJGYL_BHDJ] [nvarchar](1) NULL,
	[ZL_DJ] [nvarchar](1) NULL,
	[BH_DJ] [nvarchar](1) NULL,
	[LYFQ] [nvarchar](6) NULL,
	[QYKZ] [nvarchar](1) NULL,
	[BCLD] [nvarchar](1) NULL,
	[BHYY] [nvarchar](2) NULL,
	[BHND] [nvarchar](4) NULL,
	[DI_MAO] [nvarchar](1) NULL,
	[HBG] [int] NULL,
	[PO_XIANG] [nvarchar](1) NULL,
	[PO_WEI] [nvarchar](1) NULL,
	[PO_DU] [nvarchar](2) NULL,
	[TU_RANG_LX] [nvarchar](3) NULL,
	[TU_CENG_HD] [int] NULL,
	[KZLYH] [int] NULL,
	[FZCH] [int] NULL,
	[SLHL] [int] NULL,
	[CTMY] [nvarchar](1) NULL,
	[QSLX] [nvarchar](1) NULL,
	[QSCD] [nvarchar](1) NULL,
	[TD_TH_LX] [nvarchar](1) NULL,
	[GMYSZ] [nvarchar](6) NULL,
	[GMPJGD] [numeric](38, 1) NULL,
	[GMZGD] [numeric](38, 8) NULL,
	[CBYSZ] [nvarchar](6) NULL,
	[CBPJGD] [numeric](38, 1) NULL,
	[CBZGD] [numeric](38, 8) NULL,
	[GXYSSZ] [nvarchar](6) NULL,
	[GXPJNL] [int] NULL,
	[GXPJGD] [numeric](38, 1) NULL,
	[GXGQZS] [int] NULL,
	[GXFBQK] [nvarchar](1) NULL,
	[GXSZQK] [nvarchar](1) NULL,
	[DISPE] [nvarchar](2) NULL,
	[DISASTER_C] [nvarchar](1) NULL,
	[JKZK] [nvarchar](1) NULL,
	[SMHLX] [nvarchar](1) NULL,
	[SMHCD] [nvarchar](1) NULL,
	[SMHCY] [nvarchar](2) NULL,
	[SHLX] [nvarchar](3) NULL,
	[SHCD] [nvarchar](1) NULL,
	[SDLX] [nvarchar](2) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[JYLX] [nvarchar](2) NULL,
	[QLJG] [nvarchar](1) NULL,
	[ZRD] [nvarchar](1) NULL,
	[JYCSLX] [nvarchar](2) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[YSMG] [numeric](38, 1) NULL,
	[KE_JI_DU] [nvarchar](1) NULL,
	[JJLCQ] [nvarchar](1) NULL,
	[SSLX] [nvarchar](1) NULL,
	[SSZYSZ] [nvarchar](6) NULL,
	[SSZZS] [int] NULL,
	[SSPJXJ] [numeric](38, 1) NULL,
	[SSPJGD] [numeric](38, 1) NULL,
	[XZWZL] [nvarchar](2) NULL,
	[XZWCD] [numeric](38, 1) NULL,
	[XZWKD] [numeric](38, 1) NULL,
	[LD_KD] [numeric](38, 8) NULL,
	[LD_CD] [numeric](38, 8) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[CCLDJ] [nvarchar](1) NULL,
	[XJBDJ] [nvarchar](3) NULL,
	[PINGJUN_NL] [int] NULL,
	[PINGJUN_XJ] [numeric](38, 1) NULL,
	[PINGJUN_SG] [numeric](38, 1) NULL,
	[PINGJUN_DM] [numeric](38, 1) NULL,
	[MEI_GQ_ZS] [int] NULL,
	[BSSZ] [nvarchar](6) NULL,
	[BSSZQY] [nvarchar](2) NULL,
	[BSSZNL] [int] NULL,
	[BSSZSG] [numeric](38, 1) NULL,
	[BSSZPJXJ] [numeric](38, 1) NULL,
	[BSSZGQDM] [numeric](38, 1) NULL,
	[BSSZGQZS] [int] NULL,
	[QHFQBH] [nvarchar](4) NULL,
	[LDSYDW] [numeric](38, 8) NULL,
	[FRZLDW] [numeric](38, 8) NULL,
	[YXMJ] [numeric](38, 2) NULL,
	[XZWMJ] [numeric](38, 2) NULL,
	[ZXJ] [int] NULL,
	[SLXJ] [int] NULL,
	[YSSZXJ] [int] NULL,
	[BSSZXJ] [int] NULL,
	[SSXJ] [int] NULL,
	[HUO_LMGQXJ] [numeric](38, 2) NULL,
	[ZFNL] [int] NULL,
	[ZLND] [int] NULL,
	[LING_ZU] [nvarchar](1) NULL,
	[LJ] [nvarchar](3) NULL,
	[BAK1] [numeric](38, 8) NULL,
	[BAK2] [numeric](38, 8) NULL,
	[XBID] [nvarchar](30) NULL,
	[Remarks] [nvarchar](60) NULL,
	[GXSJ] [nvarchar](8) NULL,
	[NO_TB] [nvarchar](20) NULL,
	[Q_SQ_D] [nvarchar](2) NULL,
	[Q_GC_LB] [nvarchar](2) NULL,
	[STQW] [nvarchar](4) NULL,
	[DT_SRC] [varchar](10) NULL,
	[SHAPE] [geometry] NULL,
	[YDZL] [varchar](1) NULL,
	[KJD] [nvarchar](1) NULL,
	[GBHJZSL] [nvarchar](1) NULL,
	[JYGLLX] [nvarchar](1) NULL,
	[GLLX] [nvarchar](2) NULL,
 CONSTRAINT [R50_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_PADDING ON
CREATE SPATIAL INDEX [S14_idx] ON [dbo].[FOR_XBBH_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i17]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i17](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i17_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i18]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i18](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i18_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i19]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i19](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i19_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i2]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i2](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i2_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i20]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i20](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i20_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i21]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i21](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i21_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i22]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i22](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i22_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i23]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i23](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i23_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i24]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i24](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i24_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i25]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i25](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i25_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i29]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i29](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i29_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i3]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i3](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i3_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i30]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i30](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i30_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i31]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i31](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i31_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i32]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i32](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i32_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i34]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i34](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i34_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i35]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i35](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i35_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i37]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i37](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i37_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i38]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i38](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i38_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i39]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i39](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i39_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i4]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i4](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i4_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i40]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i40](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i40_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i41]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i41](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i41_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i42]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i42](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i42_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i43]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i43](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i43_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i44]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i44](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i44_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i45]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i45](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i45_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i46]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i46](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i46_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i48]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i48](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i48_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i5]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i5](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i5_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i50]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i50](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i50_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i51]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i51](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i51_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i52]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i52](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i52_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i53]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i53](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i53_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i54]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i54](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i54_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i55]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i55](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i55_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i56]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i56](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i56_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i57]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i57](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i57_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i58]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i58](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i58_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i59]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i59](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i59_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i6]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i6](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i6_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i60]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i60](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i60_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i61]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i61](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i61_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i62]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i62](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i62_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i68]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i68](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i68_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i69]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i69](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i69_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i7]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i7](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i7_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i70]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i70](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i70_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_ras_5]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_ras_5](
	[raster_id] [int] NOT NULL,
	[raster_flags] [int] NULL,
	[description] [nvarchar](65) NULL,
 CONSTRAINT [SDE_ras_5_pk] PRIMARY KEY CLUSTERED 
(
	[raster_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_ras_4]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_ras_4](
	[raster_id] [int] NOT NULL,
	[raster_flags] [int] NULL,
	[description] [nvarchar](65) NULL,
 CONSTRAINT [SDE_ras_4_pk] PRIMARY KEY CLUSTERED 
(
	[raster_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_process_information]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_process_information](
	[sde_id] [int] NOT NULL,
	[spid] [int] NOT NULL,
	[server_id] [int] NOT NULL,
	[start_time] [datetime] NOT NULL,
	[rcount] [int] NOT NULL,
	[wcount] [int] NOT NULL,
	[opcount] [int] NOT NULL,
	[numlocks] [int] NOT NULL,
	[fb_partial] [int] NOT NULL,
	[fb_count] [int] NOT NULL,
	[fb_fcount] [int] NOT NULL,
	[fb_kbytes] [int] NOT NULL,
	[owner] [nvarchar](30) NOT NULL,
	[direct_connect] [varchar](1) NOT NULL,
	[sysname] [nvarchar](32) NOT NULL,
	[nodename] [nvarchar](256) NOT NULL,
	[xdr_needed] [varchar](1) NOT NULL,
	[table_name] [nvarchar](95) NOT NULL,
 CONSTRAINT [process_pk] PRIMARY KEY CLUSTERED 
(
	[sde_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_state_lineages]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_state_lineages](
	[lineage_name] [bigint] NOT NULL,
	[lineage_id] [bigint] NOT NULL,
 CONSTRAINT [state_lineages_pk] PRIMARY KEY CLUSTERED 
(
	[lineage_name] ASC,
	[lineage_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [lineage_id_idx2] ON [dbo].[SDE_state_lineages] 
(
	[lineage_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_server_config]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_server_config](
	[prop_name] [nvarchar](32) NOT NULL,
	[char_prop_value] [nvarchar](512) NULL,
	[num_prop_value] [int] NULL,
 CONSTRAINT [server_config_pk] PRIMARY KEY CLUSTERED 
(
	[prop_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_spatial_references]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_spatial_references](
	[srid] [int] NOT NULL,
	[description] [nvarchar](64) NULL,
	[auth_name] [nvarchar](255) NULL,
	[auth_srid] [int] NULL,
	[falsex] [float] NOT NULL,
	[falsey] [float] NOT NULL,
	[xyunits] [float] NOT NULL,
	[falsez] [float] NOT NULL,
	[zunits] [float] NOT NULL,
	[falsem] [float] NOT NULL,
	[munits] [float] NOT NULL,
	[xycluster_tol] [float] NULL,
	[zcluster_tol] [float] NULL,
	[mcluster_tol] [float] NULL,
	[object_flags] [int] NOT NULL,
	[srtext] [varchar](1024) NOT NULL,
 CONSTRAINT [spatial_ref_pk] PRIMARY KEY CLUSTERED 
(
	[srid] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_lineages_modified]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_lineages_modified](
	[lineage_name] [bigint] NOT NULL,
	[time_last_modified] [datetime] NOT NULL,
 CONSTRAINT [lineages_mod_pk] PRIMARY KEY CLUSTERED 
(
	[lineage_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_object_ids]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_object_ids](
	[id_type] [int] NOT NULL,
	[base_id] [bigint] NOT NULL,
	[object_type] [varchar](30) NOT NULL,
 CONSTRAINT [object_ids_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_logfile_pool]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_logfile_pool](
	[table_id] [int] NOT NULL,
	[sde_id] [int] NULL,
 CONSTRAINT [logfile_pool_pk] PRIMARY KEY CLUSTERED 
(
	[table_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_locators]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_locators](
	[locator_id] [int] NOT NULL,
	[name] [nvarchar](32) NOT NULL,
	[owner] [nvarchar](32) NOT NULL,
	[category] [nvarchar](32) NOT NULL,
	[type] [int] NOT NULL,
	[description] [nvarchar](64) NULL,
 CONSTRAINT [sdelocators_pk] PRIMARY KEY CLUSTERED 
(
	[locator_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY],
 CONSTRAINT [sdelocators_uk] UNIQUE NONCLUSTERED 
(
	[name] ASC,
	[owner] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_object_locks]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_object_locks](
	[sde_id] [int] NOT NULL,
	[object_id] [int] NOT NULL,
	[object_type] [int] NOT NULL,
	[application_id] [int] NOT NULL,
	[autolock] [char](1) NOT NULL,
	[lock_type] [char](1) NOT NULL,
 CONSTRAINT [object_locks_pk] PRIMARY KEY CLUSTERED 
(
	[sde_id] ASC,
	[object_id] ASC,
	[object_type] ASC,
	[application_id] ASC,
	[autolock] ASC,
	[lock_type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_metadata]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_metadata](
	[record_id] [int] NOT NULL,
	[object_database] [nvarchar](32) NULL,
	[object_name] [nvarchar](160) NOT NULL,
	[object_owner] [nvarchar](32) NOT NULL,
	[object_type] [int] NOT NULL,
	[class_name] [nvarchar](32) NULL,
	[property] [nvarchar](32) NULL,
	[prop_value] [nvarchar](255) NULL,
	[description] [nvarchar](65) NULL,
	[creation_date] [datetime] NOT NULL,
 CONSTRAINT [sdemetadata_pk] PRIMARY KEY CLUSTERED 
(
	[record_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[SDE_get_current_user_name]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_get_current_user_name]
@current_user NVARCHAR (128) OUTPUT AS SET NOCOUNT ON
BEGIN
 DECLARE @delimiter INTEGER
 DECLARE @owner NVARCHAR(128)
 -- Get current user name. Format the user name as quoted identifier
 -- if the current user name does not comply with the rules for the format of
 -- regular identifiers

 SET @current_user = user_name()
 SET @delimiter = charindex('~', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex ('.', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex ('%', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex ('^', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex ('(', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex (')', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex ('-', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex ('{', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex ('}', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex (' ', @current_user)
 IF @delimiter = 0
   SET @delimiter = charindex ('\', @current_user)
 IF  @delimiter <> 0
 BEGIN
   SET  @current_user = N'"' + user_name() + N'"'
 END
 -- This stored prcedure will return current user name in upper case format 
 -- if the database is case insenstive. In order to know if the database is case
 -- sensitive, here to compare the @current_user to the same string but in upper 
 -- case. If they are equal, then the database is case insenstive and uppercase 
 -- format of current user name will be returned. 
 SET  @owner = UPPER(@current_user)
 IF  @current_user = @owner 
   SET  @current_user = @owner
END
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY9]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY9](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom9_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY8]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY8](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom8_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY7]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY7](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom7_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY6]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY6](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom6_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY5]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY5](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom5_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY4]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY4](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom4_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY32]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY32](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom32_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY31]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY31](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom31_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY30]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY30](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom30_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY3]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY3](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom3_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY26]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY26](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom26_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY25]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY25](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom25_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY24]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY24](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom24_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY23]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY23](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom23_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY22]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY22](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom22_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY21]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY21](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom21_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY20]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY20](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom20_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY2]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY2](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom2_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY19]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY19](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom19_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY18]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY18](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom18_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY17]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY17](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom17_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY16]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY16](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom16_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY15]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY15](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom15_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY14]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY14](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom14_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY12]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY12](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom12_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY10]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY10](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom10_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_GEOMETRY1]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_GEOMETRY1](
	[GEOMETRY_ID] [int] NOT NULL,
	[CAD] [varbinary](max) NULL,
 CONSTRAINT [geom1_idx] PRIMARY KEY CLUSTERED 
(
	[GEOMETRY_ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[i8]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i8](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i8_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i9]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i9](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i9_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i71]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i71](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i71_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i72]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i72](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i72_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i74]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i74](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i74_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[i76]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[i76](
	[id_type] [int] NOT NULL,
	[base_id] [int] NOT NULL,
	[num_ids] [int] NOT NULL,
	[last_id] [int] NULL,
 CONSTRAINT [i76_pk] PRIMARY KEY CLUSTERED 
(
	[id_type] ASC,
	[num_ids] ASC,
	[base_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_bnd_5]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_bnd_5](
	[rasterband_id] [int] NOT NULL,
	[sequence_nbr] [int] NOT NULL,
	[raster_id] [int] NOT NULL,
	[name] [nvarchar](65) NULL,
	[band_flags] [int] NOT NULL,
	[band_width] [int] NOT NULL,
	[band_height] [int] NOT NULL,
	[band_types] [int] NOT NULL,
	[block_width] [int] NOT NULL,
	[block_height] [int] NOT NULL,
	[block_origin_x] [float] NOT NULL,
	[block_origin_y] [float] NOT NULL,
	[eminx] [float] NOT NULL,
	[eminy] [float] NOT NULL,
	[emaxx] [float] NOT NULL,
	[emaxy] [float] NOT NULL,
	[cdate] [int] NOT NULL,
	[mdate] [int] NOT NULL,
 CONSTRAINT [SDE_bnd_5_pk] PRIMARY KEY NONCLUSTERED 
(
	[rasterband_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY],
 CONSTRAINT [SDE_bnd_5_uk2] UNIQUE NONCLUSTERED 
(
	[raster_id] ASC,
	[sequence_nbr] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_bnd_4]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_bnd_4](
	[rasterband_id] [int] NOT NULL,
	[sequence_nbr] [int] NOT NULL,
	[raster_id] [int] NOT NULL,
	[name] [nvarchar](65) NULL,
	[band_flags] [int] NOT NULL,
	[band_width] [int] NOT NULL,
	[band_height] [int] NOT NULL,
	[band_types] [int] NOT NULL,
	[block_width] [int] NOT NULL,
	[block_height] [int] NOT NULL,
	[block_origin_x] [float] NOT NULL,
	[block_origin_y] [float] NOT NULL,
	[eminx] [float] NOT NULL,
	[eminy] [float] NOT NULL,
	[emaxx] [float] NOT NULL,
	[emaxy] [float] NOT NULL,
	[cdate] [int] NOT NULL,
	[mdate] [int] NOT NULL,
 CONSTRAINT [SDE_bnd_4_pk] PRIMARY KEY NONCLUSTERED 
(
	[rasterband_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY],
 CONSTRAINT [SDE_bnd_4_uk2] UNIQUE NONCLUSTERED 
(
	[raster_id] ASC,
	[sequence_nbr] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_blk_5]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_blk_5](
	[rasterband_id] [int] NOT NULL,
	[rrd_factor] [int] NOT NULL,
	[row_nbr] [int] NOT NULL,
	[col_nbr] [int] NOT NULL,
	[block_data] [varbinary](max) NOT NULL,
 CONSTRAINT [SDE_blk_5_pk] PRIMARY KEY CLUSTERED 
(
	[rasterband_id] ASC,
	[rrd_factor] ASC,
	[row_nbr] ASC,
	[col_nbr] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_blk_4]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_blk_4](
	[rasterband_id] [int] NOT NULL,
	[rrd_factor] [int] NOT NULL,
	[row_nbr] [int] NOT NULL,
	[col_nbr] [int] NOT NULL,
	[block_data] [varbinary](max) NOT NULL,
 CONSTRAINT [SDE_blk_4_pk] PRIMARY KEY CLUSTERED 
(
	[rasterband_id] ASC,
	[rrd_factor] ASC,
	[row_nbr] ASC,
	[col_nbr] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_aux_5]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_aux_5](
	[rasterband_id] [int] NOT NULL,
	[type] [int] NOT NULL,
	[object] [varbinary](max) NOT NULL,
 CONSTRAINT [SDE_aux_5_pk] PRIMARY KEY CLUSTERED 
(
	[rasterband_id] ASC,
	[type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_aux_4]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_aux_4](
	[rasterband_id] [int] NOT NULL,
	[type] [int] NOT NULL,
	[object] [varbinary](max) NOT NULL,
 CONSTRAINT [SDE_aux_4_pk] PRIMARY KEY CLUSTERED 
(
	[rasterband_id] ASC,
	[type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[INDEX_A_10K]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[INDEX_A_10K](
	[OBJECTID] [int] NOT NULL,
	[新图幅号] [nvarchar](30) NULL,
	[旧图幅号] [nvarchar](30) NULL,
	[地名] [nvarchar](30) NULL,
	[带号] [nvarchar](2) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R62_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING ON
CREATE SPATIAL INDEX [S26_idx] ON [dbo].[INDEX_A_10K] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(104.4375, 20.875, 112.0625, 26.416667), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[SDE_keyset_remove]    Script Date: 03/19/2014 09:13:53 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_keyset_remove]
@tableNameVal sysname
AS
BEGIN
BEGIN TRAN keyset_tran
DECLARE @sql AS NVARCHAR(256)
SET @sql = N'DROP TABLE dbo.' + @tableNameVal
EXECUTE (@sql)
COMMIT TRAN keyset_tran
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_keyset_delete]    Script Date: 03/19/2014 09:13:53 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_keyset_delete]
@tableNameVal sysname,
@keysetIdVal INTEGER
AS
BEGIN
BEGIN TRAN keyset_tran
DECLARE @sql AS NVARCHAR(256)
SET @sql = N'DELETE FROM dbo.' + @tableNameVal + N'WHERE KEYSET_ID = ' + @keysetIdVal
EXECUTE (@sql)
COMMIT TRAN keyset_tran
END
GO
/****** Object:  UserDefinedFunction [dbo].[SDE_is_user_sde_dba]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[SDE_is_user_sde_dba] () RETURNS INTEGER
BEGIN
  --This is a private support function for SDE versioned views.
  DECLARE @user  NVARCHAR (128)
  DECLARE @is_dba INTEGER

  SELECT @user = user_name()
  IF ((@user <> 'dbo') AND (IS_SRVROLEMEMBER ('sysadmin') <> 1)) 
  BEGIN
    IF (IS_MEMBER('db_owner') <> 1) 
      SET @is_dba = 0 -- is not dba
    ELSE
      SET @is_dba = 1 -- is dba
  END
  ELSE
    SET @is_dba = 1 -- is dba

  RETURN @is_dba
END
GO
/****** Object:  Table [dbo].[SDE_dbtune]    Script Date: 03/19/2014 09:13:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_dbtune](
	[keyword] [nvarchar](32) NOT NULL,
	[parameter_name] [nvarchar](32) NOT NULL,
	[config_string] [nvarchar](2048) NULL,
 CONSTRAINT [dbtune_pk] PRIMARY KEY CLUSTERED 
(
	[keyword] ASC,
	[parameter_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_layer_locks]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_layer_locks](
	[sde_id] [int] NOT NULL,
	[layer_id] [int] NOT NULL,
	[autolock] [char](1) NOT NULL,
	[lock_type] [char](1) NOT NULL,
	[minx] [bigint] NULL,
	[miny] [bigint] NULL,
	[maxx] [bigint] NULL,
	[maxy] [bigint] NULL,
 CONSTRAINT [layer_locks_pk] PRIMARY KEY CLUSTERED 
(
	[sde_id] ASC,
	[layer_id] ASC,
	[autolock] ASC,
	[lock_type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  View [dbo].[SDE_generate_guid]    Script Date: 03/19/2014 09:13:53 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [dbo].[SDE_generate_guid] AS 
 SELECT '{' + CONVERT(NVARCHAR(36),newid()) + '}' as guidstr
GO
/****** Object:  Table [dbo].[SDE_versions]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_versions](
	[name] [nvarchar](64) NOT NULL,
	[owner] [nvarchar](32) NOT NULL,
	[version_id] [int] NOT NULL,
	[status] [int] NOT NULL,
	[state_id] [bigint] NOT NULL,
	[description] [nvarchar](64) NULL,
	[parent_name] [nvarchar](64) NULL,
	[parent_owner] [nvarchar](32) NULL,
	[parent_version_id] [int] NULL,
	[creation_time] [datetime] NOT NULL,
 CONSTRAINT [versions_pk] PRIMARY KEY CLUSTERED 
(
	[version_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY],
 CONSTRAINT [versions_uk] UNIQUE NONCLUSTERED 
(
	[name] ASC,
	[owner] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_version]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_version](
	[MAJOR] [int] NOT NULL,
	[MINOR] [int] NOT NULL,
	[BUGFIX] [int] NOT NULL,
	[DESCRIPTION] [nvarchar](96) NOT NULL,
	[RELEASE] [int] NOT NULL,
	[SDESVR_REL_LOW] [int] NOT NULL,
 CONSTRAINT [version_pk] PRIMARY KEY CLUSTERED 
(
	[MAJOR] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_tables_modified]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_tables_modified](
	[table_name] [sysname] NOT NULL,
	[time_last_modified] [datetime] NOT NULL,
 CONSTRAINT [tables_modified_pk] PRIMARY KEY CLUSTERED 
(
	[table_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_table_registry]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_table_registry](
	[registration_id] [int] NOT NULL,
	[database_name] [nvarchar](32) NULL,
	[table_name] [sysname] NOT NULL,
	[owner] [nvarchar](32) NOT NULL,
	[rowid_column] [nvarchar](32) NULL,
	[description] [nvarchar](65) NULL,
	[object_flags] [int] NOT NULL,
	[registration_date] [int] NOT NULL,
	[config_keyword] [nvarchar](32) NULL,
	[minimum_id] [int] NULL,
	[imv_view_name] [nvarchar](32) NULL,
 CONSTRAINT [registry_pk] PRIMARY KEY CLUSTERED 
(
	[registration_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY],
 CONSTRAINT [registry_uk2] UNIQUE NONCLUSTERED 
(
	[table_name] ASC,
	[owner] ASC,
	[database_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_table_locks]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_table_locks](
	[sde_id] [int] NOT NULL,
	[registration_id] [int] NOT NULL,
	[lock_type] [char](1) NOT NULL,
 CONSTRAINT [table_locks_pk] PRIMARY KEY CLUSTERED 
(
	[sde_id] ASC,
	[registration_id] ASC,
	[lock_type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[SDE_state_locks]    Script Date: 03/19/2014 09:13:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[SDE_state_locks](
	[sde_id] [int] NOT NULL,
	[state_id] [bigint] NOT NULL,
	[autolock] [char](1) NOT NULL,
	[lock_type] [char](1) NOT NULL,
 CONSTRAINT [state_locks_pk] PRIMARY KEY CLUSTERED 
(
	[sde_id] ASC,
	[state_id] ASC,
	[autolock] ASC,
	[lock_type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[T_ZT_HZ_INFO]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_ZT_HZ_INFO](
	[OBJECTID] [int] NOT NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[DIMING] [nvarchar](50) NULL,
	[QHSJ] [datetime2](7) NULL,
	[PHSJ] [datetime2](7) NULL,
	[TOTAL_MJ] [numeric](38, 2) NULL,
	[YSL_MJ] [numeric](38, 2) NULL,
	[RGL_MJ] [numeric](38, 2) NULL,
	[LINFEN] [nvarchar](30) NULL,
	[SS_CL] [int] NULL,
	[SS_YL] [numeric](38, 4) NULL,
	[SS_ZLMJ] [numeric](38, 2) NULL,
	[SHANG_Q] [int] NULL,
	[SHANG_Z] [int] NULL,
	[SHANG_S] [int] NULL,
	[SS_MONEY] [numeric](38, 8) NULL,
	[PU_RG] [int] NULL,
	[PU_CL] [int] NULL,
	[PU_QC] [int] NULL,
	[PU_FJ] [int] NULL,
	[PU_JF] [numeric](38, 8) NULL,
	[SF_CL] [nvarchar](1) NULL,
	[CL_RS] [int] NULL,
	[CL_XSRS] [int] NULL,
	[HZYY] [nvarchar](2) NULL,
	[FIRE_NO] [nvarchar](20) NULL,
	[HZDJ] [nvarchar](1) NULL,
	[NL] [nvarchar](30) NULL
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [R7_SDE_ROWID_UK] ON [dbo].[T_ZT_HZ_INFO] 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_ZT_CF_SZ_JC_TO_CZ]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_ZT_CF_SZ_JC_TO_CZ](
	[OBJECTID] [int] NOT NULL,
	[JCSZ] [nvarchar](10) NOT NULL,
	[CJSZ] [nvarchar](10) NOT NULL
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [R8_SDE_ROWID_UK] ON [dbo].[T_ZT_CF_SZ_JC_TO_CZ] 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_ZT_CF_SZ_JC_TO_CC]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_ZT_CF_SZ_JC_TO_CC](
	[OBJECTID] [int] NOT NULL,
	[JCSZ] [nvarchar](10) NOT NULL,
	[CCSZ] [nvarchar](10) NOT NULL
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [R9_SDE_ROWID_UK] ON [dbo].[T_ZT_CF_SZ_JC_TO_CC] 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_ZT_CF_MMJC]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_ZT_CF_MMJC](
	[OBJECTID] [int] NOT NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[DCXB] [nvarchar](4) NULL,
	[ZYXB] [nvarchar](10) NULL,
	[BZDH] [nvarchar](2) NULL,
	[BZDMJ] [numeric](38, 2) NULL,
	[JCSZ] [nvarchar](6) NULL,
	[JJ] [int] NULL,
	[JCLX] [nvarchar](1) NULL,
	[YCZS] [int] NULL,
	[BYCZS] [int] NULL,
	[XCZS] [int] NULL,
	[ZSHJ] [int] NULL,
	[D1] [numeric](38, 1) NULL,
	[H1] [numeric](38, 1) NULL,
	[D2] [numeric](38, 1) NULL,
	[H2] [numeric](38, 1) NULL,
	[D3] [numeric](38, 1) NULL,
	[H3] [numeric](38, 1) NULL,
	[PJG] [numeric](38, 1) NULL,
	[PJZJ] [numeric](38, 1) NULL,
	[CJ] [numeric](38, 8) NULL,
	[YCXJ] [decimal](38, 4) NULL,
	[BYCXJ] [decimal](38, 4) NULL,
	[XCXJ] [decimal](38, 4) NULL,
	[GGCCCLV] [numeric](38, 8) NULL,
	[XCCCLV] [numeric](38, 8) NULL,
	[GGCCCL] [numeric](38, 8) NULL,
	[XCCCL] [numeric](38, 8) NULL,
	[DMJ] [decimal](38, 4) NULL
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [R10_SDE_ROWID_UK] ON [dbo].[T_ZT_CF_MMJC] 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_ZT_CF_CCLB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_ZT_CF_CCLB](
	[OBJECTID] [int] NOT NULL,
	[SZ] [nvarchar](6) NULL,
	[JJ] [int] NULL,
	[D] [numeric](38, 8) NULL,
	[Z] [numeric](38, 8) NULL,
	[X] [numeric](38, 8) NULL,
	[HJ] [numeric](38, 8) NULL,
	[DX] [numeric](38, 8) NULL,
	[SP] [numeric](38, 8) NULL
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [R11_SDE_ROWID_UK] ON [dbo].[T_ZT_CF_CCLB] 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_USER_AUTHOR]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_USER_AUTHOR](
	[USER_ID] [int] NULL,
	[AUTHOR_ID] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_YCLSZHB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_YCLSZHB](
	[SORTID] [int] NULL,
	[CNAME] [nvarchar](20) NULL,
	[MERGERULE] [nvarchar](254) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_XJLJSSZHB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_XJLJSSZHB](
	[JSLX] [numeric](38, 8) NULL,
	[SZZNAME] [nvarchar](254) NULL,
	[SZHBBDS] [nvarchar](254) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_TABLE]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_TABLE](
	[SNO] [nvarchar](20) NULL,
	[TAB_ID] [nvarchar](12) NULL,
	[TAB_NAME] [nvarchar](50) NULL,
	[TAB_ALIA] [nvarchar](50) NULL,
	[TAB_TYPE] [nvarchar](8) NULL,
	[TAB_THE] [nvarchar](8) NULL,
	[LINKTYPE] [nvarchar](50) NULL,
	[TAB_EXT] [nvarchar](254) NULL,
	[TAB_CAT] [nvarchar](254) NULL,
	[ISLINK] [int] NULL,
	[ISCTAB] [int] NULL,
	[ISMTAB] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_SLSZHB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_SLSZHB](
	[SORTID] [int] NULL,
	[CNAME] [nvarchar](20) NULL,
	[MERGERULE] [nvarchar](254) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_QMLSZHB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_QMLSZHB](
	[SORTID] [int] NULL,
	[CNAME] [nvarchar](20) NULL,
	[MERGERULE] [nvarchar](254) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_LJLZ]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_LJLZ](
	[NAME] [nvarchar](50) NULL,
	[LIN_ZHONG] [nvarchar](50) NULL,
	[QI_YUAN] [nvarchar](50) NULL,
	[DI_LEI] [nvarchar](50) NULL,
	[YOU_SHI_SZ] [nvarchar](250) NULL,
	[LJQX] [int] NULL,
	[ZFNL] [int] NULL,
	[A1] [int] NULL,
	[A2] [int] NULL,
	[B1] [int] NULL,
	[B2] [int] NULL,
	[C1] [int] NULL,
	[C2] [int] NULL,
	[D1] [int] NULL,
	[D2] [int] NULL,
	[E] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_LDZZBCBZB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_LDZZBCBZB](
	[BCLXCODE] [nvarchar](4) NULL,
	[BCLXNAME] [nvarchar](40) NULL,
	[BCDJ] [numeric](38, 8) NULL,
	[TJBDS] [nvarchar](150) NULL,
	[XIAN] [nvarchar](40) NULL,
	[BCBZJLND] [nvarchar](10) NULL,
	[BZ] [nvarchar](100) NULL,
	[XMMC] [nvarchar](100) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_JJLSZHB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_JJLSZHB](
	[SORTID] [int] NULL,
	[CNAME] [nvarchar](20) NULL,
	[MERGERULE] [nvarchar](254) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_JJLCQ]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_JJLCQ](
	[LB] [nvarchar](10) NULL,
	[YOU_SHI_SZ] [nvarchar](254) NULL,
	[SZMC] [nvarchar](10) NULL,
	[A1] [int] NULL,
	[A2] [int] NULL,
	[B1] [int] NULL,
	[B2] [int] NULL,
	[C1] [int] NULL,
	[C2] [int] NULL,
	[D] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_HSLSZHB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_HSLSZHB](
	[SORTID] [int] NULL,
	[CNAME] [nvarchar](20) NULL,
	[MERGERULE] [nvarchar](254) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_GYLQW]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_GYLQW](
	[XH] [int] NOT NULL,
	[DM] [nvarchar](4) NULL,
	[STQW] [nvarchar](12) NOT NULL,
	[MC] [nvarchar](40) NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_GROWTHMODEL]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_GROWTHMODEL](
	[MODELBH] [int] NOT NULL,
	[XIANCODE] [nvarchar](10) NULL,
	[XIANNAME] [nvarchar](50) NULL,
	[JLSJ] [nvarchar](10) NULL,
	[MODELTYPE] [nvarchar](50) NULL,
	[SZZNAME] [nvarchar](20) NULL,
	[SZZGBBDS] [nvarchar](200) NULL,
	[PJHGS] [nvarchar](200) NULL,
	[PJDGS] [nvarchar](200) NULL,
	[MGQXJJSGS] [nvarchar](200) NULL,
	[SSXJXS] [numeric](38, 8) NULL,
	[BZ] [nvarchar](50) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_GMLSZHB]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_GMLSZHB](
	[SORTID] [int] NULL,
	[CNAME] [nvarchar](20) NULL,
	[MERGERULE] [nvarchar](254) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_FIELDS]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_FIELDS](
	[TAB_ID] [nvarchar](15) NULL,
	[FIEL_NA] [nvarchar](50) NULL,
	[FIEL_AL] [nvarchar](50) NULL,
	[FIEL_TY] [nvarchar](10) NULL,
	[FIEL_SCA] [nvarchar](10) NULL,
	[FIEL_UNI] [nvarchar](10) NULL,
	[CTABLE] [nvarchar](50) NULL,
	[CODE_IND] [nvarchar](50) NULL,
	[ISNACOL] [nvarchar](10) NULL,
	[ISINDEX] [nvarchar](10) NULL,
	[ISFULL] [nvarchar](10) NULL,
	[FIEL_LOG] [nvarchar](50) NULL,
	[ISAUTO] [nvarchar](10) NULL,
	[FIEL_EXT] [nvarchar](50) NULL,
	[FIEL_IND] [smallint] NULL,
	[FIEL_LEN] [nvarchar](10) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_CODEINDEX]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_CODEINDEX](
	[TYPE] [nvarchar](50) NULL,
	[CODE] [nvarchar](4) NULL,
	[DOMAINNAME] [nvarchar](30) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_META_CODE]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_META_CODE](
	[PCODE] [nvarchar](20) NULL,
	[CCODE] [nvarchar](20) NULL,
	[CNAME] [nvarchar](50) NULL,
	[CSNAME] [nvarchar](50) NULL,
	[CTYPE] [nvarchar](22) NULL,
	[CCATOG] [nvarchar](20) NULL,
	[CDOMAIN] [nvarchar](50) NULL,
	[CEXTINF] [nvarchar](254) NULL,
	[CINDEX] [nvarchar](10) NULL,
	[CYEAR] [int] NULL,
	[CLEN] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_LD_ADMIN_CODES]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_LD_ADMIN_CODES](
	[PCODE] [nvarchar](20) NULL,
	[CCODE] [nvarchar](20) NULL,
	[CNAME] [nvarchar](50) NULL,
	[CTYPE] [nvarchar](22) NULL,
	[CNAM] [nvarchar](50) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_FLOW_USER]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_FLOW_USER](
	[USER_ID] [int] NOT NULL,
	[USER_NAME] [nvarchar](30) NULL,
	[USER_PASSWORD] [nvarchar](50) NULL,
	[USER_NOTE] [nvarchar](200) NULL,
	[CREATE_TIME] [datetime2](7) NULL,
	[USER_SEX] [nvarchar](10) NULL,
	[USER_PHONE] [nvarchar](50) NULL,
	[USER_EMAIL] [nvarchar](50) NULL,
	[USER_DEPT] [int] NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_FLOW_DEPT]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_FLOW_DEPT](
	[DEPT_ID] [int] NULL,
	[DEPT_NAME] [nvarchar](80) NULL,
	[DEPT_NOTE] [nvarchar](255) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_FLOW_AUTHOR]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_SYS_FLOW_AUTHOR](
	[AUTHOR_ID] [int] NOT NULL,
	[AUTHOR_NAME] [nvarchar](255) NULL,
	[AUTHOR_NOTE] [nvarchar](80) NULL,
	[SYSTEM_ZT] [nvarchar](10) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_SYS_DB_INFO]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[T_SYS_DB_INFO](
	[V_ITEM] [varchar](50) NOT NULL,
	[V_VALUE] [varchar](max) NULL,
	[V_MEMO] [varchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[V_ITEM] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
/****** Object:  Table [dbo].[T_STAT_REPORT]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_STAT_REPORT](
	[Theme] [nvarchar](10) NULL,
	[ReportID] [int] NOT NULL,
	[ReportName] [nvarchar](50) NOT NULL,
	[DataTable] [nvarchar](50) NULL,
	[TableSql] [nvarchar](max) NULL,
	[StoredProcedure] [nvarchar](20) NULL,
	[StoredProcedureSql] [nvarchar](max) NULL,
	[UseStoredProcedure] [nvarchar](1) NULL,
	[StaticSQL] [nvarchar](max) NULL,
	[StartIndex] [int] NULL,
	[GroupIndex] [nvarchar](1000) NULL,
	[DtColIndex] [int] NULL,
	[reportyear] [int] NULL,
	[IsShow] [int] NULL,
	[MergeColIndex] [nvarchar](30) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_LOG]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_LOG](
	[USER_NAME] [nvarchar](50) NULL,
	[OPERATE] [nvarchar](50) NULL,
	[LOG_TIME] [datetime2](7) NULL,
	[REMARK] [nvarchar](255) NULL,
	[SYSTEM] [nvarchar](50) NULL,
	[ID] [int] IDENTITY(1,1) NOT NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_EDITTASK_ZT]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_EDITTASK_ZT](
	[ID] [int] NULL,
	[taskname] [nvarchar](100) NULL,
	[taskkind] [nvarchar](10) NULL,
	[distcode] [nvarchar](12) NULL,
	[taskstate] [nvarchar](1) NULL,
	[taskpath] [nvarchar](100) NULL,
	[taskyear] [nvarchar](4) NULL,
	[createtime] [nvarchar](20) NULL,
	[datasetname] [nvarchar](10) NULL,
	[layername] [nvarchar](30) NULL,
	[edittime] [nvarchar](20) NULL,
	[logiccheckstate] [nvarchar](1) NULL,
	[toplogiccheckstate] [nvarchar](1) NULL,
	[tablename] [nvarchar](40) NULL,
	[bh] [nvarchar](30) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[T_DESIGNKIND]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[T_DESIGNKIND](
	[code] [nvarchar](6) NULL,
	[name] [nvarchar](80) NULL,
	[kind] [nvarchar](1) NULL
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [I554code] ON [dbo].[T_DESIGNKIND] 
(
	[code] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SYS_MAX_ID]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SYS_MAX_ID](
	[MAX_TYPE] [nvarchar](20) NULL,
	[MAX_ID] [int] NULL,
	[TYPE_NAME] [nvarchar](20) NULL
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_xml_indexes]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_xml_indexes](
	[index_id] [int] IDENTITY(1,1) NOT NULL,
	[index_name] [nvarchar](32) NOT NULL,
	[owner] [nvarchar](32) NOT NULL,
	[index_type] [int] NOT NULL,
	[description] [nvarchar](64) NULL,
 CONSTRAINT [xml_indexes_pk] PRIMARY KEY CLUSTERED 
(
	[index_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [xml_indexes_uk] ON [dbo].[SDE_xml_indexes] 
(
	[owner] ASC,
	[index_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_ZL_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_ZL_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[BHYY] [nvarchar](2) NULL,
	[TU_RANG_LX] [nvarchar](3) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[MEI_GQ_ZS] [int] NULL,
	[SEN_LIN_LB] [nvarchar](3) NULL,
	[G_CHENG_LB] [nvarchar](2) NULL,
	[LD_KD] [numeric](38, 8) NULL,
	[LD_CD] [numeric](38, 8) NULL,
	[GXSJ] [nvarchar](8) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[ZAO_LIN_MS] [nvarchar](20) NULL,
	[ZAO_LIN_LB] [nvarchar](3) NULL,
	[SSZZS] [int] NULL,
	[ZJLY] [nvarchar](2) NULL,
	[TFH] [nvarchar](50) NULL,
	[ZLHNAME] [nvarchar](50) NULL,
	[BZ] [nvarchar](50) NULL,
	[JCRY] [nvarchar](40) NULL,
	[JCSJ] [nvarchar](8) NULL,
	[ZLND] [nvarchar](4) NULL,
	[Q_SEN_LB] [nvarchar](3) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[BSSZ] [nvarchar](6) NULL,
	[FYFS] [nvarchar](1) NULL,
	[ZYTZDJ] [numeric](38, 8) NULL,
	[ZYTZJF] [numeric](38, 8) NULL,
	[DFTZDJ] [numeric](38, 8) NULL,
	[DFTZJF] [numeric](38, 8) NULL,
	[JHND] [int] NULL,
	[HSMJ] [numeric](38, 2) NULL,
	[HGMJ] [numeric](38, 2) NULL,
	[BHGMJ] [numeric](38, 2) NULL,
	[SSMJ] [numeric](38, 2) NULL,
	[BHSYY] [nvarchar](2) NULL,
	[BHGYY] [nvarchar](2) NULL,
	[SSYY] [nvarchar](1) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R43_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING ON
CREATE SPATIAL INDEX [S7_idx] ON [dbo].[ZT_ZL_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_ZH_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_ZH_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[Q_SEN_LB] [nvarchar](2) NULL,
	[SEN_LIN_LB] [nvarchar](2) NULL,
	[BHYY] [nvarchar](2) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[DISPE] [nvarchar](2) NULL,
	[DISASTER_C] [nvarchar](1) NULL,
	[ZHMJ] [numeric](38, 2) NULL,
	[SUNSHIXJ] [int] NULL,
	[BLXJ] [int] NULL,
	[GXSJ] [nvarchar](8) NULL,
	[YHSW] [nvarchar](10) NULL,
	[SSZS] [int] NULL,
	[FXRQ] [nvarchar](8) NULL,
	[JLRQ] [nvarchar](8) NULL,
	[CZDJ] [nvarchar](1) NULL,
	[SSMJ] [numeric](38, 2) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R40_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S4_idx] ON [dbo].[ZT_ZH_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_YGJC_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_YGJC_{2}](
	[OBJECTID] [int] NOT NULL,
	[NO_TB] [nvarchar](20) NULL,
	[SHENG] [nvarchar](2) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_YE_JU] [nvarchar](6) NULL,
	[LIN_CHANG] [nvarchar](9) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[PAN_DILEI] [nvarchar](1) NULL,
	[BEIZU] [nvarchar](40) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[DI_MAO] [nvarchar](1) NULL,
	[PO_XIANG] [nvarchar](1) NULL,
	[PO_DU] [nvarchar](2) NULL,
	[PO_WEI] [nvarchar](1) NULL,
	[TU_RANG_LX] [nvarchar](3) NULL,
	[TU_CENG_HD] [int] NULL,
	[LD_CD] [numeric](38, 8) NULL,
	[LD_KD] [numeric](38, 8) NULL,
	[KE_JI_DU] [nvarchar](1) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[ZL_DJ] [nvarchar](1) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[SEN_LIN_LB] [nvarchar](3) NULL,
	[G_CHENG_LB] [nvarchar](2) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[LING_ZU] [nvarchar](1) NULL,
	[PINGJUN_XJ] [numeric](38, 1) NULL,
	[PINGJUN_NL] [int] NULL,
	[PINGJUN_SG] [numeric](38, 1) NULL,
	[PINGJUN_DM] [numeric](38, 1) NULL,
	[HUO_LMGQXJ] [numeric](38, 2) NULL,
	[DISPE] [nvarchar](2) NULL,
	[DISASTER_C] [nvarchar](1) NULL,
	[TD_TH_LX] [nvarchar](1) NULL,
	[GJGYL_BHDJ] [nvarchar](1) NULL,
	[BH_DJ] [nvarchar](1) NULL,
	[QYKZ] [nvarchar](1) NULL,
	[SHI_QUAN_D] [nvarchar](2) NULL,
	[BCLD] [nvarchar](1) NULL,
	[LYFQ] [nvarchar](6) NULL,
	[BHYY] [nvarchar](2) NULL,
	[BHND] [nvarchar](4) NULL,
	[LDGLLX] [nvarchar](2) NULL,	
	[LMSYQ] [nvarchar](2) NULL,
	[MEI_GQ_ZS] [int] NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R39_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S3_idx] ON [dbo].[ZT_YGJC_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_LYAJ_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_LYAJ_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[Q_SEN_LB] [nvarchar](2) NULL,
	[SEN_LIN_LB] [nvarchar](2) NULL,
	[BHYY] [nvarchar](2) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[MEI_GQ_ZS] [int] NULL,
	[BLXJ] [int] NULL,
	[GXSJ] [nvarchar](8) NULL,
	[AJLX] [nvarchar](1) NULL,
	[XWZT] [nvarchar](1) NULL,
	[SSLDMJ] [numeric](38, 2) NULL,
	[SSLMXJ] [int] NULL,
	[SSLMZJ] [int] NULL,
	[SSMZZS] [int] NULL,
	[SSYSMMZS] [int] NULL,
	[FSRQ] [nvarchar](8) NULL,
	[JLRQ] [nvarchar](8) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R38_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S2_idx] ON [dbo].[ZT_LYAJ_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_LDZZ_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_LDZZ_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [decimal](38, 4) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[BHYY] [nvarchar](2) NULL,
	[ZYBM] [nvarchar](50) NULL,
	[XFSS] [nvarchar](2) NULL,
	[GXSJ] [nvarchar](8) NULL,
	[XMBH] [nvarchar](30) NULL,
	[XMMC] [nvarchar](100) NULL,
	[LDLX] [nvarchar](2) NULL,
	[LDYT] [nvarchar](2) NULL,
	[XMLX] [nvarchar](1) NULL,
	[YDZL] [nvarchar](1) NULL,
	[YDFW] [nvarchar](1) NULL,
	[SEN_LIN_LB] [nvarchar](3) NULL,
	[SHI_QUAN_D] [nvarchar](2) NULL,
	[GJGYL_BHDJ] [nvarchar](1) NULL,
	[BH_DJ] [nvarchar](1) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[JJLCQ] [nvarchar](1) NULL,
	[XZWZL] [nvarchar](2) NULL,
	[XZWCD] [numeric](38, 1) NULL,
	[XZWKD] [numeric](38, 1) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[PINGJUN_NL] [int] NULL,
	[PINGJUN_XJ] [numeric](38, 1) NULL,
	[PINGJUN_SG] [numeric](38, 1) NULL,
	[PINGJUN_DM] [numeric](38, 1) NULL,
	[LING_ZU] [nvarchar](1) NULL,
	[XZWMJ] [numeric](38, 2) NULL,
	[SLXJ] [int] NULL,
	[XBID] [nvarchar](30) NULL,
	[SFTGD] [nvarchar](2) NULL,
	[BZ] [nvarchar](50) NULL,
	[LDBCDJ] [numeric](38, 8) NULL,
	[LDBCF] [numeric](38, 8) NULL,
	[LDAZFDJ] [numeric](38, 8) NULL,
	[LDAZF] [numeric](38, 8) NULL,
	[LMBCDJ] [numeric](38, 8) NULL,
	[LMBCF] [numeric](38, 8) NULL,
	[BCFHJ] [numeric](38, 8) NULL,
	[ZBHFDJ] [numeric](38, 8) NULL,
	[ZBHFF] [numeric](38, 8) NULL,
	[ZFYHJ] [numeric](38, 8) NULL,
	[SHSJ] [nvarchar](8) NULL,
	[Q_SEN_LB] [nvarchar](3) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[QYKZ] [nvarchar](1) NULL,
	[LYFQ] [nvarchar](6) NULL,
	[ZL_DJ] [nvarchar](1) NULL,
	[SPMJ] [decimal](38, 4) NULL,
	[MEI_GQ_ZS] [int] NULL,
	[BSSZ] [nvarchar](6) NULL,
	[SPJB] [nvarchar](1) NULL,
	[ZJFWDX] [nvarchar](1) NULL,
	[SHAPE] [geometry] NULL,
	[PZWH] [nvarchar](50) NULL,
	[JLSJ] [nvarchar](8) NULL,
 CONSTRAINT [R44_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S8_idx] ON [dbo].[ZT_LDZZ_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_L_LDZZ_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_L_LDZZ_{2}](
	[OBJECTID] [int] NOT NULL,
	[XMBH] [nvarchar](30) NULL,
	[XH] [nvarchar](16) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R41_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S5_idx] ON [dbo].[ZT_L_LDZZ_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_HZ_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_HZ_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[Q_SEN_LB] [nvarchar](2) NULL,
	[SEN_LIN_LB] [nvarchar](2) NULL,
	[BHYY] [nvarchar](2) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[DISPE] [nvarchar](2) NULL,
	[DISASTER_C] [nvarchar](1) NULL,
	[ZHMJ] [numeric](38, 2) NULL,
	[SUNSHIXJ] [int] NULL,
	[BLXJ] [int] NULL,
	[GXSJ] [nvarchar](8) NULL,
	[PINGJUN_NL] [numeric](38, 8) NULL,
	[LING_ZU] [nvarchar](1) NULL,
	[SS_ZS] [numeric](38, 8) NULL,
	[FIRE_NO] [nvarchar](20) NULL,
	[HZDJ] [nvarchar](1) NULL,
	[HZYY] [nvarchar](2) NULL,
	[QHSJ] [datetime2](7) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R42_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S6_idx] ON [dbo].[ZT_HZ_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_D_LDZZ_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_D_LDZZ_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[MIAN_JI] [decimal](38, 4) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[BHYY] [nvarchar](2) NULL,
	[ZYBM] [nvarchar](50) NULL,
	[XFSS] [nvarchar](2) NULL,
	[GXSJ] [nvarchar](8) NULL,
	[XMBH] [nvarchar](30) NULL,
	[XMMC] [nvarchar](100) NULL,
	[LDLX] [nvarchar](2) NULL,
	[LDYT] [nvarchar](2) NULL,
	[XMLX] [nvarchar](1) NULL,
	[YDZL] [nvarchar](1) NULL,
	[YDFW] [nvarchar](1) NULL,
	[SEN_LIN_LB] [nvarchar](3) NULL,
	[SHI_QUAN_D] [nvarchar](2) NULL,
	[GJGYL_BHDJ] [nvarchar](1) NULL,
	[BH_DJ] [nvarchar](1) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[JJLCQ] [nvarchar](1) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[PINGJUN_NL] [int] NULL,
	[PINGJUN_XJ] [numeric](38, 1) NULL,
	[PINGJUN_SG] [numeric](38, 1) NULL,
	[PINGJUN_DM] [numeric](38, 1) NULL,
	[LING_ZU] [nvarchar](1) NULL,
	[SLXJ] [int] NULL,
	[XBID] [nvarchar](30) NULL,
	[TJMC] [nvarchar](30) NULL,
	[TJ_X] [numeric](38, 8) NULL,
	[TJ_Y] [numeric](38, 8) NULL,
	[SFTGD] [nvarchar](2) NULL,
	[BZ] [nvarchar](50) NULL,
	[LDBCDJ] [numeric](38, 8) NULL,
	[LDBCF] [numeric](38, 8) NULL,
	[LDAZFDJ] [numeric](38, 8) NULL,
	[LDAZF] [numeric](38, 8) NULL,
	[LMBCDJ] [numeric](38, 8) NULL,
	[LMBCF] [numeric](38, 8) NULL,
	[BCFHJ] [numeric](38, 8) NULL,
	[ZBHFDJ] [numeric](38, 8) NULL,
	[ZBHFF] [numeric](38, 8) NULL,
	[ZFYHJ] [numeric](38, 8) NULL,
	[SHSJ] [nvarchar](8) NULL,
	[Q_SEN_LB] [nvarchar](3) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[QYKZ] [nvarchar](1) NULL,
	[LYFQ] [nvarchar](6) NULL,
	[ZL_DJ] [nvarchar](1) NULL,
	[SPMJ] [decimal](38, 4) NULL,
	[BSSZ] [nvarchar](6) NULL,
	[SPJB] [nvarchar](1) NULL,
	[ZJFWDX] [nvarchar](1) NULL,
	[Shape] [geometry] NULL,
	[PZWH] [nvarchar](50) NULL,
	[JLSJ] [nvarchar](8) NULL,
 CONSTRAINT [R45_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S9_idx] ON [dbo].[ZT_D_LDZZ_{2}] 
(
	[Shape]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[ZT_CF_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ZT_CF_{2}](
	[OBJECTID] [int] NOT NULL,
	[SHENG] [nvarchar](2) NULL,
	[SHI] [nvarchar](4) NULL,
	[XIAN] [nvarchar](6) NULL,
	[XIANG] [nvarchar](9) NULL,
	[CUN] [nvarchar](12) NULL,
	[LIN_BAN] [nvarchar](4) NULL,
	[XIAO_BAN] [nvarchar](4) NULL,
	[SJBH] [nvarchar](50) NULL,
	[DCRY] [nvarchar](50) NULL,
	[SJRY] [nvarchar](50) NULL,
	[XIAODM] [nvarchar](50) NULL,
	[EAST] [nvarchar](30) NULL,
	[WEST] [nvarchar](30) NULL,
	[SOUTH] [nvarchar](30) NULL,
	[NORTH] [nvarchar](30) NULL,
	[LMSYZXM] [nvarchar](20) NULL,
	[DW] [nvarchar](100) NULL,
	[MIAN_JI] [numeric](38, 2) NULL,
	[Q_DI_LEI] [nvarchar](4) NULL,
	[DI_LEI] [nvarchar](4) NULL,
	[Q_LD_QS] [nvarchar](2) NULL,
	[LD_QS] [nvarchar](2) NULL,
	[TDJYQ] [nvarchar](2) NULL,
	[LMSYQ] [nvarchar](2) NULL,
	[LMJYQ] [nvarchar](2) NULL,
	[PO_XIANG] [nvarchar](1) NULL,
	[PO_DU] [nvarchar](2) NULL,
	[PO_WEI] [nvarchar](1) NULL,
	[HBG] [int] NULL,
	[CTMY] [nvarchar](1) NULL,
	[TU_RANG_LX] [nvarchar](3) NULL,
	[TU_CENG_HD] [int] NULL,
	[Q_SEN_LB] [nvarchar](3) NULL,
	[SEN_LIN_LB] [nvarchar](3) NULL,
	[Q_LIN_ZHONG] [nvarchar](3) NULL,
	[LIN_ZHONG] [nvarchar](3) NULL,
	[GJGYL_BHDJ] [nvarchar](1) NULL,
	[PINGJUN_NL] [int] NULL,
	[LING_ZU] [nvarchar](1) NULL,
	[YU_BI_DU] [numeric](38, 2) NULL,
	[QI_YUAN] [nvarchar](2) NULL,
	[YOU_SHI_SZ] [nvarchar](6) NULL,
	[PINGJUN_XJ] [numeric](38, 1) NULL,
	[PINGJUN_SG] [numeric](38, 1) NULL,
	[HUO_LMGQXJ] [numeric](38, 2) NULL,
	[MEI_GQ_ZS] [int] NULL,
	[ZXJ] [int] NULL,
	[FQZS] [int] NULL,
	[CFLX] [nvarchar](2) NULL,
	[CFFS] [nvarchar](2) NULL,
	[CFQD] [int] NULL,
	[CFMJ] [numeric](38, 2) NULL,
	[CFXJ] [int] NULL,
	[GGCCCL] [numeric](38, 8) NULL,
	[FGGCCCL] [numeric](38, 8) NULL,
	[CCLV] [numeric](38, 8) NULL,
	[BLMGQZS] [int] NULL,
	[BLMYBD] [numeric](38, 2) NULL,
	[CFSJ] [nvarchar](8) NULL,
	[FMFF] [nvarchar](30) NULL,
	[JCFS] [nvarchar](1) NULL,
	[GENGXINSJ] [nvarchar](50) NULL,
	[GXMJ] [numeric](38, 2) NULL,
	[GXSZ] [nvarchar](6) NULL,
	[GXFS] [nvarchar](2) NULL,
	[ZDFS] [nvarchar](50) NULL,
	[ZDGG] [nvarchar](50) NULL,
	[ZLMD] [int] NULL,
	[ZHUHJ] [nvarchar](50) NULL,
	[MIAOMUGG] [nvarchar](50) NULL,
	[YML] [int] NULL,
	[FYCS] [nvarchar](50) NULL,
	[GXZRR] [nvarchar](50) NULL,
	[QTSM] [nvarchar](250) NULL,
	[CFCS] [int] NULL,
	[PJGF] [numeric](38, 8) NULL,
	[SSZZS] [int] NULL,
	[SSXJ] [int] NULL,
	[GXDJ] [nvarchar](1) NULL,
	[BHYY] [nvarchar](2) NULL,
	[GXSJ] [nvarchar](8) NULL,
	[SFCF] [nvarchar](2) NULL,
	[IS_COPIED] [nvarchar](1) NULL,
	[CFZS] [int] NULL,
	[BLMGQXJ] [numeric](38, 2) NULL,
	[XI_BAN] [nvarchar](10) NULL,
	[TASK_ID] [nvarchar](50) NULL,
	[SHAPE] [geometry] NULL,
 CONSTRAINT [R46_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S10_idx] ON [dbo].[ZT_CF_{2}] 
(
	[SHAPE]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  View [dbo].[V_LD_ZT_{2}]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [dbo].[V_LD_ZT_{2}] AS SELECT * FROM (SELECT objectid,XIAN,XIANG,CUN,LIN_BAN,XIAO_BAN,XI_BAN,MIAN_JI,BHYY,Q_DI_LEI,DI_LEI,Q_LD_QS,LD_QS,Q_LIN_ZHONG,LIN_ZHONG,Q_SEN_LB,SEN_LIN_LB,SHAPE,'ZT_CF_{2}' AS tablename FROM ZT_CF_{2} UNION ALL SELECT objectid,XIAN,XIANG,CUN,LIN_BAN,XIAO_BAN,XI_BAN,MIAN_JI,BHYY,Q_DI_LEI,DI_LEI,Q_LD_QS,LD_QS,Q_LIN_ZHONG,LIN_ZHONG,Q_SEN_LB,SEN_LIN_LB,SHAPE,'ZT_LDZZ_{2}' as tablename from ZT_LDZZ_{2} union all select objectid,XIAN,XIANG,CUN,LIN_BAN,XIAO_BAN,XI_BAN,MIAN_JI,BHYY,Q_DI_LEI,DI_LEI,Q_LD_QS,LD_QS,Q_LIN_ZHONG,LIN_ZHONG,Q_SEN_LB,SEN_LIN_LB,SHAPE,'ZT_LYAJ_{2}' as tablename from  ZT_LYAJ_{2} union all select objectid,XIAN,XIANG,CUN,LIN_BAN,XIAO_BAN,XI_BAN,MIAN_JI,BHYY,Q_DI_LEI,DI_LEI,Q_LD_QS,LD_QS,Q_LIN_ZHONG,LIN_ZHONG,Q_SEN_LB,SEN_LIN_LB,SHAPE,'ZT_ZH_{2}' as tablename from ZT_ZH_{2} union all select objectid,XIAN,XIANG,CUN,LIN_BAN,XIAO_BAN,XI_BAN,MIAN_JI,BHYY,Q_DI_LEI,DI_LEI,Q_LD_QS,LD_QS,Q_LIN_ZHONG,LIN_ZHONG,Q_SEN_LB,SEN_LIN_LB,SHAPE,'ZT_ZL_{2}' AS tablename FROM ZT_ZL_{2} UNION ALL SELECT objectid,XIAN,XIANG,CUN,LIN_BAN,XIAO_BAN,XI_BAN,MIAN_JI,BHYY,Q_DI_LEI,DI_LEI,Q_LD_QS,LD_QS,Q_LIN_ZHONG,LIN_ZHONG,Q_SEN_LB,SEN_LIN_LB,SHAPE,'ZT_HZ_{2}' AS tablename FROM ZT_HZ_{2})a
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_indexes_def_update]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_indexes_def_update]
@index_id INTEGER, @indexNameVal NVARCHAR(32),
@descriptionVal NVARCHAR(64)
AS SET NOCOUNT ON
BEGIN
  UPDATE FORDATA_{1}.dbo.SDE_xml_indexes
   SET index_name = @indexNameVal, description = @descriptionVal
   WHERE index_id = @index_id
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_indexes_def_insert]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_indexes_def_insert]
@ownerVal NVARCHAR(32),@indexNameVal NVARCHAR(32),
@indexTypeVal INTEGER, @descriptionVal NVARCHAR(64) AS
SET NOCOUNT ON BEGIN
INSERT INTO FORDATA_{1}.dbo.SDE_xml_indexes(index_name, owner, index_type, description) VALUES 
  (@indexNameVal, @ownerVal, @indexTypeVal, @descriptionVal)
DECLARE @index_id INTEGER
SELECT @index_id = @@IDENTITY
RETURN @index_id
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_indexes_def_delete]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_indexes_def_delete]
@ownerVal NVARCHAR(32),@indexNameVal NVARCHAR(64) AS
SET NOCOUNT ON BEGIN
BEGIN TRAN xml_index_del
-- Delete index record. Cascading constraint will delete from FORDATA_{1}.dbo.SDE_xml_index_tags 
DELETE FROM FORDATA_{1}.dbo.SDE_xml_indexes
  WHERE owner = @ownerVal AND index_name = @indexNameVal
COMMIT TRAN xml_index_del
END
GO
/****** Object:  View [dbo].[ST_SPATIAL_REFERENCE_SYSTEMS]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [dbo].[ST_SPATIAL_REFERENCE_SYSTEMS] (srs_id, x_offset,       x_scale, y_offset, y_scale, z_offset, z_scale, m_offset,        m_scale, organization,organization_coordsys_id, definition)       AS SELECT srid, falsex, xyunits, falsey, xyunits,       falsez, zunits, falsem, munits,        auth_name, auth_srid, srtext  FROM       FORDATA_{1}.dbo.SDE_spatial_references
GO
/****** Object:  Table [dbo].[SDE_states]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_states](
	[state_id] [bigint] NOT NULL,
	[owner] [nvarchar](32) NOT NULL,
	[creation_time] [datetime] NOT NULL,
	[closing_time] [datetime] NULL,
	[parent_state_id] [bigint] NOT NULL,
	[lineage_name] [bigint] NOT NULL,
 CONSTRAINT [states_pk] PRIMARY KEY CLUSTERED 
(
	[state_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY],
 CONSTRAINT [states_cuk] UNIQUE NONCLUSTERED 
(
	[parent_state_id] ASC,
	[lineage_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[SDE_xml_columns]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_xml_columns](
	[column_id] [int] IDENTITY(1,1) NOT NULL,
	[registration_id] [int] NOT NULL,
	[column_name] [nvarchar](32) NOT NULL,
	[index_id] [int] NULL,
	[minimum_id] [int] NULL,
	[config_keyword] [nvarchar](32) NULL,
	[xflags] [int] NOT NULL,
 CONSTRAINT [xml_columns_pk] PRIMARY KEY NONCLUSTERED 
(
	[column_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE UNIQUE CLUSTERED INDEX [xml_columns_uk] ON [dbo].[SDE_xml_columns] 
(
	[registration_id] ASC,
	[column_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[SDE_versions_def_update]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_versions_def_update]        @statusVal INTEGER, @descVal NVARCHAR(64), @nameVal NVARCHAR(64),        @ownerVal NVARCHAR(32) AS SET NOCOUNT ON UPDATE FORDATA_{1}.dbo.SDE_versions SET status = @statusVal,        description = @descVal WHERE name = @nameVal and owner = @ownerVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_versions_def_rename_parent]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_versions_def_rename_parent] @newNameVal     NVARCHAR(64), @oldNameVal NVARCHAR(64), @ownerVal NVARCHAR(32) AS    UPDATE FORDATA_{1}.dbo.SDE_versions     SET parent_name = @newNameVal WHERE parent_name = @oldNameVal    AND parent_owner = @ownerVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_versions_def_rename]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_versions_def_rename] @newNameVal     NVARCHAR(64), @oldNameVal NVARCHAR(64), @ownerVal NVARCHAR(32) AS    DECLARE @result INTEGER    SET @result = 0    IF UPPER(@ownerVal) = 'dbo' AND UPPER(@oldNameVal) = 'DEFAULT'      SET @result = -25 /* SE_NO_PERMISSIONS */    ELSE      UPDATE FORDATA_{1}.dbo.SDE_versions SET name = @newNameVal        WHERE name = @oldNameVal and owner = @ownerVal    RETURN @result
GO
/****** Object:  StoredProcedure [dbo].[SDE_versions_def_insert]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_versions_def_insert]
@nameVal NVARCHAR(64) OUTPUT, @ownerVal NVARCHAR(32), @versionIdVal INTEGER,
@statusVal INTEGER, @stateIdVal BIGINT, @descVal NVARCHAR(64),
@pNameVal NVARCHAR(64), @pOwnerVal NVARCHAR(32), @pVersionIdVal INTEGER,
@dateVal DATETIME, @nameRuleVal INTEGER AS SET NOCOUNT ON
BEGIN
  DECLARE @suffix INTEGER
  DECLARE @ret_code INTEGER
  DECLARE @err_code INTEGER
  DECLARE @error_string NVARCHAR(256)
  DECLARE @local_version_name NVARCHAR(65)
  DECLARE @done INTEGER

  DECLARE @SE_VERSION_EXIST INTEGER
  SET @SE_VERSION_EXIST = 50177

  SET @local_version_name = RTRIM (@nameVal)
  SET @done = 0
  SET @suffix = 0

  WHILE @done = 0
  BEGIN 
    INSERT INTO FORDATA_{1}.dbo.SDE_versions (name, owner, version_id, status,
      state_id, description, parent_name, parent_owner,
      parent_version_id, creation_time) VALUES (
      @local_version_name,@ownerVal,@versionIdVal,@statusVal,@stateIdVal,
      @descVal,@pNameVal,@pOwnerVal,@pVersionIdVal,@dateVal)
    SET @err_code = @@error
    IF @err_code = 0
    BEGIN
      -- Insert worked, exit loop
      SET @done = 1
      SET @ret_code = 0
    END
    ELSE
    BEGIN
      IF @err_code = 2627
      BEGIN
        IF @nameRuleVal = 1
        BEGIN
          -- Unique constraint violation, let's try to generate a
          -- unique name
          SET @suffix = @suffix + 1
          SET @local_version_name = RTRIM (@nameVal) +
                                    cast (@suffix AS NVARCHAR(10))
          IF LEN (@local_version_name) > 64
          BEGIN
            SET @done = 1
            SET @ret_code = @SE_VERSION_EXIST
            SET @error_string = N'Unable to generate a name for ' + @nameVal
            RAISERROR (@error_string,16,-1)
          END
        END
        ELSE
        BEGIN
          -- Unique constraint violation, and we are not generating
          -- unique names
          SET @done = 1
          SET @ret_code = @SE_VERSION_EXIST
          SET @error_string = N'Version ' +  @nameVal + N' already exists.'
          RAISERROR (@error_string,16,-1)
        END
      END
      ELSE
      BEGIN
        -- Some other error occurred
        SET @done = 1
        SET @ret_code = @err_code
        SET @error_string = N'Unable to create version ' +  @nameVal
        RAISERROR (@error_string,16,-1)
      END
    END
  END

  -- Set the returned name, in case we changed it.
  SET @nameVal = @local_version_name

  RETURN @ret_code
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_versions_def_delete]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_versions_def_delete]       @ownerVal NVARCHAR(32), @nameVal  NVARCHAR(64) AS SET NOCOUNT ON      DECLARE @result INTEGER      SET @result = 0      IF UPPER(@ownerVal) = UPPER('dbo') AND UPPER(@nameVal) = 'DEFAULT'        SET @result = -25 /* SE_NO_PERMISSIONS */      ELSE        DELETE FROM FORDATA_{1}.dbo.SDE_versions WHERE owner = @ownerVal AND name = @nameVal      RETURN @result
GO
/****** Object:  StoredProcedure [dbo].[SDE_versions_def_change_state]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_versions_def_change_state] @newStateIdVal BIGINT,      @nameVal NVARCHAR(64), @ownerVal NVARCHAR(32), @oldStateIdVal BIGINT AS      UPDATE FORDATA_{1}.dbo.SDE_versions SET       state_id = @newStateIdVal WHERE name = @nameVal and owner = @ownerVal AND       state_id = @oldStateIdVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_table_lock_def_delete_user]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_table_lock_def_delete_user] @sdeIdVal INTEGER AS SET NOCOUNT ON     BEGIN TRAN table_lock_tran     DELETE FROM FORDATA_{1}.dbo.SDE_table_locks WHERE  sde_id = @sdeIdVal     COMMIT TRAN table_lock_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_table_lock_def_delete]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_table_lock_def_delete] @sdeIdVal INTEGER, @registrationIdVal INTEGER AS     SET NOCOUNT ON BEGIN TRAN table_lock_del_tran     DECLARE @ret_val INTEGER     DELETE FROM FORDATA_{1}.dbo.SDE_table_locks WITH (TABLOCKX) WHERE  sde_id = @sdeIdVal AND     registration_id = @registrationIdVal     IF @@ROWCOUNT = 0 SET @ret_val = -48 /* SE_NO_LOCKS */     ELSE SET @ret_val = 0 /* SE_SUCCESS */     COMMIT TRAN table_lock_del_tran     RETURN @ret_val
GO
/****** Object:  Table [dbo].[SDE_xml_index_tags]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_xml_index_tags](
	[index_id] [int] NOT NULL,
	[tag_id] [int] IDENTITY(1,1) NOT NULL,
	[tag_name] [nvarchar](1024) NOT NULL,
	[data_type] [int] NOT NULL,
	[tag_alias] [int] NULL,
	[description] [nvarchar](64) NULL,
	[is_excluded] [int] NOT NULL,
 CONSTRAINT [xml_indextags_pk] PRIMARY KEY CLUSTERED 
(
	[index_id] ASC,
	[tag_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [xml_indextags_ix1] ON [dbo].[SDE_xml_index_tags] 
(
	[tag_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [xml_indextags_ix2] ON [dbo].[SDE_xml_index_tags] 
(
	[tag_alias] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[SDE_dbtune_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_dbtune_def_update]       @keywordVal NVARCHAR(32),@parameter_nameVal NVARCHAR(32),       @config_stringVal NVARCHAR(2048) AS UPDATE FORDATA_{1}.dbo.SDE_dbtune       SET  config_string = @config_stringVal WHERE       keyword = @keywordVal AND parameter_name = @parameter_nameVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_dbtune_def_truncate]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_dbtune_def_truncate]       AS SET NOCOUNT ON DELETE FROM FORDATA_{1}.dbo.SDE_dbtune
GO
/****** Object:  StoredProcedure [dbo].[SDE_dbtune_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_dbtune_def_insert]       @keywordVal NVARCHAR(32),@parameter_nameVal NVARCHAR(32),       @config_stringVal NVARCHAR(2048) AS INSERT INTO FORDATA_{1}.dbo.SDE_dbtune       (keyword,parameter_name,config_string) VALUES       (@keywordVal,@parameter_nameVal,@config_stringVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_dbtune_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_dbtune_def_delete]       @keywordVal NVARCHAR(32),@parameter_nameVal NVARCHAR(32)       AS IF (@parameter_nameVal IS NULL)        DELETE FROM FORDATA_{1}.dbo.SDE_dbtune WHERE keyword = @keywordVal      ELSE DELETE FROM FORDATA_{1}.dbo.SDE_dbtune WHERE keyword = @keywordVal AND           parameter_name = @parameter_nameVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_last_modified_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_last_modified_def_update]
@tableNameVal sysname,
@newTimeVal DATETIME OUTPUT AS SET NOCOUNT ON
BEGIN TRAN last_modified_tran
DECLARE @current_time DATETIME
SELECT @current_time = time_last_modified
  FROM FORDATA_{1}.dbo.SDE_tables_modified WITH (TABLOCKX, HOLDLOCK)
  WHERE table_name = @tableNameVal
IF @@ROWCOUNT = 0
BEGIN
  /* Insert a value for this table */
  INSERT INTO FORDATA_{1}.dbo.SDE_tables_modified (table_name,time_last_modified)
VALUES (@tableNameVal, @newTimeVal)
END
ELSE
BEGIN
  /* Never let the last_time_modifed remain the same or decrement */
  IF DATEDIFF (second, @current_time, @newTimeVal) <= 0
    SET @newTimeVal = DATEADD(second, 1, @current_time)
  UPDATE FORDATA_{1}.dbo.SDE_tables_modified SET time_last_modified = @newTimeVal
    WHERE table_name = @tableNameVal
END
COMMIT TRAN last_modified_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_last_lineage_mod_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_last_lineage_mod_def_insert]
@lineageNameVal BIGINT,
@newTimeVal DATETIME AS SET NOCOUNT ON
BEGIN TRAN last_lineage_mod_tran
DECLARE @current_time DATETIME
SELECT @current_time = time_last_modified
  FROM FORDATA_{1}.dbo.SDE_lineages_modified WITH (TABLOCKX, HOLDLOCK)
  WHERE lineage_name = @lineageNameVal
IF @@ROWCOUNT > 0
BEGIN
/* Never let the last_time_modifed remain the same or decrement */
  IF DATEDIFF (second, @current_time, @newTimeVal) <= 0
    SET @newTimeVal = DATEADD(second, 1, @current_time)
  UPDATE FORDATA_{1}.dbo.SDE_lineages_modified SET time_last_modified = @newTimeVal
    WHERE lineage_name = @lineageNameVal
END
ELSE
  INSERT INTO FORDATA_{1}.dbo.SDE_lineages_modified (lineage_name, time_last_modified)    VALUES(@lineageNameVal,@newTimeVal)

COMMIT TRAN last_lineage_mod_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_generator_release]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_generator_release] AS SELECT 3 FROM FORDATA_{1}.dbo.SDE_version
GO
/****** Object:  StoredProcedure [dbo].[SDE_current_version_not_default]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_current_version_not_default] @current_state BIGINT AS 
SET NOCOUNT ON BEGIN
--This is a private support procedure for SDE versioned views.
--Check for default version.
  DECLARE @count INTEGER
  SELECT @count = count(*)
  FROM   FORDATA_{1}.dbo.SDE_versions 
  WHERE  name = 'DEFAULT' AND owner = 'dbo' AND state_id = @current_state
IF @count = 1
BEGIN
  DECLARE @error_string NVARCHAR(256)
  SET @error_string = 'You may not update this view on an ' +
                      'archiving table in the DEFAULT version.'
  RAISERROR (@error_string,16,-1)
  RETURN -1
END
RETURN 0
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_lock_def_delete_user]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_lock_def_delete_user] @sdeIdVal INTEGER AS SET NOCOUNT ON     BEGIN TRAN layer_lock_tran     DELETE FROM FORDATA_{1}.dbo.SDE_layer_locks WHERE  sde_id = @sdeIdVal     COMMIT TRAN layer_lock_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_lock_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_lock_def_delete] @sdeIdVal INTEGER, @layerIdVal INTEGER,     @autoLockVal VARCHAR(1) AS SET NOCOUNT ON     BEGIN TRAN layer_lock_del_tran     DECLARE @ret_val INTEGER     DELETE FROM FORDATA_{1}.dbo.SDE_layer_locks WHERE  sde_id = @sdeIdVal AND layer_id = @layerIdVal AND     autolock = @autoLockVal     IF @@ROWCOUNT = 0 SET @ret_val = -48 /* SE_NO_LOCKS */     ELSE SET @ret_val = 0 /* SE_SUCCESS */     COMMIT TRAN layer_lock_del_tran     RETURN @ret_val
GO
/****** Object:  UserDefinedFunction [dbo].[SDE_get_view_state]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[SDE_get_view_state] () RETURNS BIGINT
BEGIN
--This is a private support function for SDE versioned views.
DECLARE @state_id BIGINT
DECLARE @context_info VARCHAR(128)
SELECT @context_info = CAST (context_info AS VARCHAR(128))
FROM master.dbo.sysprocesses
WHERE spid = @@SPID AND CAST (context_info AS VARCHAR(128)) like 'SDE%'
IF @context_info IS NULL
  SET @state_id = -1  -- version has not been set.
ELSE
BEGIN
  DECLARE @delimiter INTEGER
  SET @delimiter = charindex (',', @context_info)
  IF @delimiter = 0
    SET @state_id = -1  -- version has not been set.
  ELSE
  BEGIN
    DECLARE @next_delimiter INTEGER
    SET @next_delimiter = charindex (',', @context_info, @delimiter + 1)
    SET @context_info = substring (@context_info, @delimiter + 1,
        @next_delimiter - @delimiter - 1)
    SET @state_id = CAST (@context_info as bigint)
  END
END
IF @state_id < 1
  -- Set to default version's state id
  SELECT @state_id = state_id FROM FORDATA_{1}.dbo.SDE_versions
    WHERE name = 'DEFAULT' AND owner = 'dbo'
RETURN @state_id
END
GO
/****** Object:  UserDefinedFunction [dbo].[SDE_get_version_access]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[SDE_get_version_access] (
@status INTEGER,
@version_owner NVARCHAR (128)) 
RETURNS CHAR(1) 
BEGIN
--This is a private support function for SDE versioned views.

-- Get the current login & user name
DECLARE @user      NVARCHAR (128)
DECLARE @protected CHAR (1)
DECLARE @is_dba INTEGER
DECLARE @delimiter INTEGER
SELECT @user = user_name()
SET @delimiter = PATINDEX('"%', @version_owner)
IF @delimiter > 0
BEGIN
 SET @user = N'"' + user_name() + N'"' 
END
SET @is_dba = FORDATA_{1}.dbo.SDE_is_user_sde_dba ()
SET @status = @status - floor (@status / 4) * 4
IF @status = 0 -- private version
BEGIN
  IF ((@is_dba = 0) AND (@user <> @version_owner))
    SET @protected = '2' -- no permission
  ELSE
    SET @protected = '0'; -- full permission
END
ELSE IF @status = 2 -- protected version
BEGIN
  IF ((@is_dba = 0) AND (@user <> @version_owner))
    SET @protected = '1' -- read only permission
  ELSE
    SET @protected = '0' -- full permission
END
ELSE
  SET @protected = '0' -- must be a public version
RETURN @protected
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_get_primary_oid]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_get_primary_oid]
@id_type INTEGER,
@num_ids INTEGER,
@base_id BIGINT OUTPUT
AS
BEGIN
  IF @id_type = -1
    SET @base_id = 2
  ELSE
  BEGIN
    DECLARE object_cursor CURSOR LOCAL FOR
      SELECT base_id
      FROM FORDATA_{1}.dbo.SDE_object_ids WITH (UPDLOCK)
      WHERE id_type = @id_type
      FOR UPDATE
    OPEN object_cursor
    BEGIN TRAN id_tran
    FETCH NEXT FROM object_cursor INTO @base_id
    /* update the base id */
    UPDATE FORDATA_{1}.dbo.SDE_object_ids SET base_id = base_id + @num_ids
      WHERE CURRENT OF object_cursor
    CLOSE object_cursor
    COMMIT TRAN id_tran /* releases update lock */
    DEALLOCATE object_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i9_return_ids]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i9_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i9 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i9 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i9 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i9_get_ids]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i9_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i9 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i9 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i9 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i9 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i9
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i9 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i9 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  View [dbo].[dbtune]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [dbo].[dbtune] as select * from FORDATA_{1}.dbo.SDE_dbtune
GO
/****** Object:  Table [dbo].[SDE_column_registry]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_column_registry](
	[database_name] [nvarchar](32) NOT NULL,
	[table_name] [sysname] NOT NULL,
	[owner] [nvarchar](32) NOT NULL,
	[column_name] [nvarchar](32) NOT NULL,
	[sde_type] [int] NOT NULL,
	[column_size] [int] NULL,
	[decimal_digits] [int] NULL,
	[description] [nvarchar](65) NULL,
	[object_flags] [int] NOT NULL,
	[object_id] [int] NULL,
 CONSTRAINT [colregistry_pk] PRIMARY KEY CLUSTERED 
(
	[database_name] ASC,
	[table_name] ASC,
	[owner] ASC,
	[column_name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[i74_return_ids]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i74_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i74 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i74 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i74 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i74_get_ids]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i74_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i74 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i74 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i74 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i74 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i74
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i74 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i74 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i72_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i72_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i72 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i72 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i72 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i72_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i72_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i72 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i72 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i72 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i72 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i72
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i72 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i72 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i71_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i71_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i71 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i71 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i71 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i71_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i71_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i71 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i71 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i71 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i71 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i71
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i71 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i71 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i70_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i70_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i70 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i70 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i70 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i70_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i70_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i70 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i70 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i70 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i70 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i70
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i70 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i70 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i8_return_ids]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i8_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i8 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i8 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i8 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i8_get_ids]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i8_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i8 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i8 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i8 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i8 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i8
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i8 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i8 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i76_return_ids]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i76_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i76 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i76 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i76 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i76_get_ids]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i76_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i76 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i76 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i76 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i76 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i76
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i76 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i76 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  Table [dbo].[SDE_archives]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_archives](
	[archiving_regid] [int] NOT NULL,
	[history_regid] [int] NOT NULL,
	[from_date] [nvarchar](32) NOT NULL,
	[to_date] [nvarchar](32) NOT NULL,
	[archive_date] [bigint] NOT NULL,
	[archive_flags] [bigint] NOT NULL,
 CONSTRAINT [archives_pk] PRIMARY KEY CLUSTERED 
(
	[archiving_regid] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY],
 CONSTRAINT [archives_uk] UNIQUE NONCLUSTERED 
(
	[history_regid] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  UserDefinedFunction [dbo].[retrieve_guid]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[retrieve_guid] () RETURNS NVARCHAR(38)
BEGIN
  RETURN(SELECT guidstr from FORDATA_{1}.dbo.SDE_generate_guid )
END
GO
/****** Object:  Table [dbo].[SDE_geometry_columns]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_geometry_columns](
	[f_table_catalog] [nvarchar](32) NOT NULL,
	[f_table_schema] [nvarchar](32) NOT NULL,
	[f_table_name] [sysname] NOT NULL,
	[f_geometry_column] [nvarchar](32) NOT NULL,
	[g_table_catalog] [nvarchar](32) NULL,
	[g_table_schema] [nvarchar](32) NOT NULL,
	[g_table_name] [sysname] NOT NULL,
	[storage_type] [int] NULL,
	[geometry_type] [int] NULL,
	[coord_dimension] [int] NULL,
	[max_ppr] [int] NULL,
	[srid] [int] NOT NULL,
 CONSTRAINT [geocol_pk] PRIMARY KEY CLUSTERED 
(
	[f_table_catalog] ASC,
	[f_table_schema] ASC,
	[f_table_name] ASC,
	[f_geometry_column] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[SDE_pinfo_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_pinfo_def_delete] @sdeIdVal INTEGER AS SET NOCOUNT ON     BEGIN TRAN pinfo_tran     DELETE FROM FORDATA_{1}.dbo.SDE_layer_locks WHERE sde_id = @sdeIdVal     DELETE FROM FORDATA_{1}.dbo.SDE_state_locks WHERE sde_id = @sdeIdVal     DELETE FROM FORDATA_{1}.dbo.SDE_table_locks WHERE sde_id = @sdeIdVal     DELETE FROM FORDATA_{1}.dbo.SDE_object_locks WHERE sde_id = @sdeIdVal     UPDATE FORDATA_{1}.dbo.SDE_logfile_pool SET sde_id = NULL WHERE sde_id = @sdeIdVal     DELETE FROM FORDATA_{1}.dbo.SDE_process_information WHERE sde_id = @sdeIdVal     COMMIT TRAN pinfo_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_parse_version_name]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_parse_version_name] 
@version_name NVARCHAR (97),
@parsed_name NVARCHAR (64) OUTPUT,
@parsed_owner NVARCHAR (32) OUTPUT AS SET NOCOUNT ON
BEGIN
  --This is a private support function for SDE versioned views.

  DECLARE @error_string NVARCHAR(256)
  DECLARE @delimiter INTEGER
  DECLARE @SE_INVALID_VERSION_NAME INTEGER
  SET @SE_INVALID_VERSION_NAME = 50171

  -- Parse the version name.
  SET @delimiter = PATINDEX ('%".%', @version_name)
  IF @delimiter <> 0
  BEGIN
    SET @parsed_owner = substring (@version_name, 1, @delimiter)
    SET @parsed_name = substring (@version_name, @delimiter + 2, 64)
  END
  ELSE
  BEGIN
    SET @delimiter = charindex ('.', @version_name)
    IF @delimiter <> 0
    BEGIN
      SET @parsed_owner = substring (@version_name, 1, @delimiter - 1)
      SET @parsed_name = substring (@version_name, @delimiter + 1, 64)
    END
    ELSE
    BEGIN
      SET @parsed_name = @version_name
      EXECUTE FORDATA_{1}.dbo.SDE_get_current_user_name @parsed_owner OUTPUT
    END
  END

  IF RTRIM (@parsed_name) IS NULL OR LEN (@parsed_name) = 0 OR
     RTRIM (@parsed_owner) IS NULL OR LEN (@parsed_owner) = 0
  BEGIN
    SET @error_string = ISNULL (@version_name, '(null)') +
                       ' is not a valid version name.'
    RAISERROR (@error_string,16,-1)
    RETURN @SE_INVALID_VERSION_NAME
  END

  RETURN 0
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_object_lock_def_delete_user]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_object_lock_def_delete_user] @sdeIdVal INTEGER AS SET NOCOUNT ON     BEGIN TRAN object_lock_tran     DELETE FROM FORDATA_{1}.dbo.SDE_object_locks WHERE  sde_id = @sdeIdVal     COMMIT TRAN object_lock_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_object_lock_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_object_lock_def_delete] @sdeIdVal INTEGER, @objectIdVal INTEGER,     @objectTypeVal INTEGER, @applicationIdVal INTEGER,     @autoLockVal VARCHAR(1) AS SET NOCOUNT ON     BEGIN TRAN object_lock_del_tran     DECLARE @ret_val INTEGER     DELETE FROM FORDATA_{1}.dbo.SDE_object_locks WHERE  sde_id = @sdeIdVal AND     object_id = @objectIdVal AND object_type = @objectTypeVal     AND application_id = @applicationIdVal AND autolock = @autoLockVal     IF @@ROWCOUNT = 0 SET @ret_val = -48 /* SE_NO_LOCKS */     ELSE SET @ret_val = 0 /* SE_SUCCESS */     COMMIT TRAN object_lock_del_tran     RETURN @ret_val
GO
/****** Object:  StoredProcedure [dbo].[SDE_logfile_pool_release_id]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_logfile_pool_release_id]
@tableIdVal INTEGER
AS SET NOCOUNT ON
BEGIN TRAN logfile_tran
  UPDATE FORDATA_{1}.dbo.SDE_logfile_pool SET sde_id = NULL
    WHERE table_id = @tableIdVal
COMMIT TRAN logfile_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_logfile_pool_get_id]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_logfile_pool_get_id]
@sdeIdVal INTEGER,
@checkOrphansVal INTEGER,
@useTruncateVal INTEGER
AS
BEGIN TRAN logfile_tran
DECLARE @table_id INTEGER
SET @table_id = 0
SELECT TOP 1 @table_id = table_id
  FROM FORDATA_{1}.dbo.SDE_logfile_pool WITH (TABLOCKX, HOLDLOCK)
  WHERE sde_id IS NULL
IF @@ROWCOUNT > 0
BEGIN
  /* Grab this table */
  UPDATE FORDATA_{1}.dbo.SDE_logfile_pool SET sde_id = @sdeIdVal
    WHERE table_id = @table_id
END
ELSE
BEGIN
  IF @checkOrphansVal = 1
  BEGIN
    /* Check if any of the tables are orphaned */
    SELECT TOP 1 @table_id = LP.table_id FROM FORDATA_{1}.dbo.SDE_logfile_pool LP
    LEFT JOIN (SELECT PR.sde_id FROM FORDATA_{1}.dbo.SDE_process_information PR 
    INNER JOIN  tempdb.sys.objects      SO ON object_id (PR.table_name) = SO.object_id
    WHERE SO.object_id IS NOT NULL) SPR
    ON LP.sde_id = SPR.sde_id WHERE SPR.sde_id IS NULL
    IF @@ROWCOUNT > 0
    BEGIN
      /* Grab this orphaned table */
      UPDATE FORDATA_{1}.dbo.SDE_logfile_pool SET sde_id = @sdeIdVal
        WHERE table_id = @table_id
    END
  END
END
/* If we got a table, truncate it in case the last user did
   not clean it up properly. */
IF @table_id > 0
BEGIN
  DECLARE @sqlstmt AS VARCHAR (64)
  IF @useTruncateVal = 1
  BEGIN
    SET @sqlstmt = 'TRUNCATE TABLE dbo.SDE_logpool_' + cast (@table_id as varchar(10))
  END
  ELSE
  BEGIN
    SET @sqlstmt = 'DELETE FROM dbo.SDE_logpool_' + cast (@table_id as varchar(10))
  END
  EXEC (@sqlstmt)
END
COMMIT TRAN logfile_tran
RETURN @table_id
GO
/****** Object:  StoredProcedure [dbo].[SDE_locator_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_locator_def_update] @locator_idVal INTEGER,      @categoryVal NVARCHAR(32), @typeVal INTEGER, @descriptionVal NVARCHAR(64),      @nameVal NVARCHAR(32) AS SET NOCOUNT ON      UPDATE FORDATA_{1}.dbo.SDE_locators SET name = @nameVal, category = @categoryVal,type = @typeVal,      description = @descriptionVal WHERE locator_id = @locator_idVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_locator_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_locator_def_insert]       @locator_idVal INTEGER,@categoryVal NVARCHAR(32),@typeVal INTEGER,       @descriptionVal NVARCHAR(64), @nameVal NVARCHAR(32),       @ownerVal NVARCHAR(32) AS SET NOCOUNT ON INSERT INTO FORDATA_{1}.dbo.SDE_locators      (locator_id,category,type,description,name,owner) VALUES (      @locator_idVal,@categoryVal,@typeVal,@descriptionVal,@nameVal,@ownerVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_locator_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_locator_def_delete] @id1        INTEGER AS SET NOCOUNT ON DELETE FROM FORDATA_{1}.dbo.SDE_locators WHERE locator_id = @id1
GO
/****** Object:  Table [dbo].[SDE_layers]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_layers](
	[layer_id] [int] NOT NULL,
	[description] [nvarchar](65) NULL,
	[database_name] [nvarchar](32) NOT NULL,
	[table_name] [sysname] NOT NULL,
	[owner] [nvarchar](32) NOT NULL,
	[spatial_column] [nvarchar](32) NOT NULL,
	[eflags] [int] NOT NULL,
	[layer_mask] [int] NOT NULL,
	[gsize1] [float] NOT NULL,
	[gsize2] [float] NOT NULL,
	[gsize3] [float] NOT NULL,
	[minx] [float] NOT NULL,
	[miny] [float] NOT NULL,
	[maxx] [float] NOT NULL,
	[maxy] [float] NOT NULL,
	[minz] [float] NULL,
	[maxz] [float] NULL,
	[minm] [float] NULL,
	[maxm] [float] NULL,
	[cdate] [int] NOT NULL,
	[layer_config] [nvarchar](32) NULL,
	[optimal_array_size] [int] NULL,
	[stats_date] [int] NULL,
	[minimum_id] [int] NULL,
	[srid] [int] NOT NULL,
	[base_layer_id] [int] NOT NULL,
	[secondary_srid] [int] NULL,
 CONSTRAINT [layers_pk] PRIMARY KEY CLUSTERED 
(
	[database_name] ASC,
	[table_name] ASC,
	[owner] ASC,
	[spatial_column] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY],
 CONSTRAINT [layers_uk] UNIQUE NONCLUSTERED 
(
	[layer_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[SDE_server_config_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_server_config_insert]
 @PropNameVal NVARCHAR(32),
    @CharPropVal NVARCHAR(512),
    @NumPropVal INTEGER AS SET NOCOUNT ON
    UPDATE FORDATA_{1}.dbo.SDE_server_config SET prop_name = UPPER(@PropNameVal), 
    char_prop_value = @CharPropVal, 
     num_prop_value = @NumPropVal WHERE prop_name =  UPPER(@PropNameVal) 

    IF @@ROWCOUNT = 0 
     INSERT INTO FORDATA_{1}.dbo.SDE_server_config (prop_name,char_prop_value,num_prop_value) 
     VALUES (UPPER(@PropNameVal),@CharPropVal,@NumPropVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_metadata_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_metadata_def_update]       @record_idVal INTEGER, @class_nameVal      NVARCHAR(32), @propertyVal NVARCHAR(32), @prop_valueVal NVARCHAR(255),        @descriptionVal NVARCHAR(64), @creation_dateVal DATETIME AS      SET NOCOUNT ON UPDATE FORDATA_{1}.dbo.SDE_metadata      SET class_name = @class_nameVal,property = @propertyVal,      prop_value = @prop_valueVal,description = @descriptionVal,      creation_date = @creation_dateVal WHERE record_id = @record_idVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_metadata_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_metadata_def_insert]       @record_idVal INTEGER, @object_nameVal NVARCHAR(32), @object_databaseVal NVARCHAR(32),       @object_ownerVal NVARCHAR(32),@object_typeVal INTEGER, @class_nameVal      NVARCHAR(32), @propertyVal NVARCHAR(32), @prop_valueVal NVARCHAR(255),        @descriptionVal NVARCHAR(64), @creation_dateVal DATETIME AS SET NOCOUNT ON      INSERT INTO FORDATA_{1}.dbo.SDE_metadata      (record_id,object_name,object_database,object_owner,object_type,class_name,property,      prop_value,description,creation_date) VALUES (@record_idVal, @object_nameVal,      @object_databaseVal, @object_ownerVal, @object_typeVal, @class_nameVal, @propertyVal,      @prop_valueVal, @descriptionVal, @creation_dateVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_metadata_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_metadata_def_delete] @id1        INTEGER, @id2 INTEGER, @id3 INTEGER, @id4 INTEGER, @id5 INTEGER,        @id6 INTEGER, @id7 INTEGER, @id8 INTEGER, @id9 INTEGER, @id10 INTEGER AS       SET NOCOUNT ON DELETE FROM FORDATA_{1}.dbo.SDE_metadata WHERE record_id IN (       @id1, @id2, @id3, @id4, @id5, @id6, @id7, @id8, @id9, @id10)
GO
/****** Object:  StoredProcedure [dbo].[SDE_registry_def_change_table_name]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_registry_def_change_table_name]       @tabNameVal sysname, @regIdVal INTEGER AS SET NOCOUNT ON
      UPDATE m set m.object_name = @tabNameVal from FORDATA_{1}.dbo.SDE_metadata m 
       INNER JOIN FORDATA_{1}.dbo.SDE_table_registry r ON 
       m.object_database = r.database_name AND m.object_name = r.table_name AND 
       m.object_owner = r.owner 
       WHERE  r.registration_id = @regIdVal AND m.object_type = 1 
      UPDATE FORDATA_{1}.dbo.SDE_table_registry SET table_name = @tabNameVal WHERE registration_id = @regIdVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_registry_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_registry_def_update]        @rowidColVal NVARCHAR(32), @descVal NVARCHAR(65), @objFlagsVal INTEGER,       @conKeyWordVal  NVARCHAR(32), @minIdVal INTEGER, @regIdVal INTEGER,       @imvNameVal NVARCHAR (32) AS SET NOCOUNT ON       UPDATE FORDATA_{1}.dbo.SDE_table_registry SET rowid_column = @rowidColVal, description = @descVal,       object_flags = @objFlagsVal ,config_keyword = @conKeyWordVal,       minimum_id = @minIdVal, imv_view_name = @imvNameVal       WHERE registration_id = @regIdVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_registry_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_registry_def_insert]        @regIdVal INTEGER, @dbNameVal NVARCHAR(32), @tabNameVal sysname, @ownerVal NVARCHAR(32),       @rowidColVal NVARCHAR(32), @descVal NVARCHAR(65), @objFlagsVal INTEGER,       @regDate INTEGER, @conKeyWordVal  NVARCHAR(32), @minIdVal INTEGER,        @imvNameVal NVARCHAR(32) AS SET NOCOUNT ON       INSERT INTO FORDATA_{1}.dbo.SDE_table_registry (registration_id, database_name, table_name, owner,       rowid_column,description,object_flags,registration_date,       config_keyword,minimum_id,imv_view_name) VALUES ( @regIdVal, @dbNameVal, @tabNameVal,       @ownerVal,@rowidColVal, @descVal, @objFlagsVal, @regDate, @conKeyWordVal, @minIdVal,       @imvNameVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_lock_def_delete_user]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_lock_def_delete_user] @sdeIdVal INTEGER AS SET NOCOUNT ON     BEGIN TRAN state_lock_tran     DELETE FROM FORDATA_{1}.dbo.SDE_state_locks WHERE  sde_id = @sdeIdVal     COMMIT TRAN state_lock_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_lock_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_lock_def_delete]
@sdeIdVal INTEGER,
@stateIdVal BIGINT,
@autoLockVal VARCHAR(1),
@markedVal INTEGER AS SET NOCOUNT ON
BEGIN TRAN state_lock_del_tran
DECLARE @ret_val INTEGER
IF (@markedVal = 0)
 DELETE FROM FORDATA_{1}.dbo.SDE_state_locks WHERE  sde_id = @sdeIdVal AND state_id = @stateIdVal AND autolock = @autoLockVal AND lock_type <> 'M'
ELSE
 DELETE FROM FORDATA_{1}.dbo.SDE_state_locks WHERE  sde_id = @sdeIdVal AND state_id = @stateIdVal AND autolock = @autoLockVal
IF @@ROWCOUNT = 0 SET @ret_val = -48 /* SE_NO_LOCKS */
ELSE SET @ret_val = 0 /* SE_SUCCESS */
COMMIT TRAN state_lock_del_tran
RETURN @ret_val
GO
/****** Object:  StoredProcedure [dbo].[SDE_sref_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_sref_def_update]       @sridVal INTEGER, @falsexVal FLOAT, @falseyVal FLOAT, @xyunitsVal FLOAT,      @falsezVal FLOAT, @zunitsVal FLOAT, @falsemVal FLOAT,       @munitsVal FLOAT, @object_flagsVal INTEGER,       @srtextVal TEXT, @descriptionVal NVARCHAR(64),       @auth_nameVal NVARCHAR(255), @auth_sridVal INTEGER,       @xycluster_tolVal FLOAT, @zcluster_tolVal FLOAT, @mcluster_tolVal FLOAT      AS SET NOCOUNT ON UPDATE FORDATA_{1}.dbo.SDE_spatial_references SET falsex = @falsexVal,       falsey = @falseyVal,xyunits = @xyunitsVal,falsez = @falsezVal,       zunits = @zunitsVal,falsem = @falsemVal,munits = @munitsVal,       object_flags = @object_flagsVal, srtext = @srtextVal,       description = @descriptionVal,       auth_name = @auth_nameVal, auth_srid = @auth_sridVal,      xycluster_tol = @xycluster_tolVal,zcluster_tol = @zcluster_tolVal,      mcluster_tol = @mcluster_tolVal      WHERE srid = @sridVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_sref_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_sref_def_insert]       @sridVal INTEGER, @falsexVal FLOAT, @falseyVal FLOAT,       @xyunitsVal FLOAT, @falsezVal FLOAT, @zunitsVal FLOAT,       @falsemVal FLOAT, @munitsVal FLOAT, @object_flagsVal INTEGER,       @srtextVal TEXT, @descriptionVal NVARCHAR(64),       @auth_nameVal NVARCHAR(255), @auth_sridVal INTEGER,       @xycluster_tolVal FLOAT, @zcluster_tolVal FLOAT, @mcluster_tolVal FLOAT      AS SET NOCOUNT ON INSERT INTO FORDATA_{1}.dbo.SDE_spatial_references       (srid,falsex,falsey,xyunits,falsez,zunits,falsem,munits,object_flags,       srtext, description,auth_name,auth_srid,xycluster_tol,zcluster_tol,      mcluster_tol) VALUES (@sridVal, @falsexVal, @falseyVal,       @xyunitsVal, @falsezVal, @zunitsVal, @falsemVal, @munitsVal,       @object_flagsVal, @srtextVal, @descriptionVal, @auth_nameVal,      @auth_sridVal, @xycluster_tolVal, @zcluster_tolVal, @mcluster_tolVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_sref_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_sref_def_delete]       @sridVal INTEGER AS SET NOCOUNT ON DELETE FROM FORDATA_{1}.dbo.SDE_spatial_references WHERE srid = @sridVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_procedure_release]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_procedure_release] AS SELECT 5000092 FROM FORDATA_{1}.dbo.SDE_version
GO
/****** Object:  StoredProcedure [dbo].[SDE_pinfo_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_pinfo_def_update] @sdeIdVal INTEGER, @rcountVal INTEGER,     @wcountVal INTEGER, @opcountVal INTEGER, @numlocksVal INTEGER,     @fb_partialVal INTEGER, @fb_countVal INTEGER, @fb_fcountVal INTEGER,     @fb_kbytesVal INTEGER AS SET NOCOUNT ON     BEGIN TRAN pinfo_tran     UPDATE FORDATA_{1}.dbo.SDE_process_information  SET rcount = @rcountVal, wcount = @wcountVal,     opcount = @opcountVal, numlocks = @numlocksVal,      fb_partial = @fb_partialVal, fb_count = @fb_countVal,     fb_fcount = @fb_fcountVal, fb_kbytes = @fb_kbytesVal     WHERE sde_id = @sdeIdVal     COMMIT TRAN pinfo_tran
GO
/****** Object:  Table [dbo].[SDE_raster_columns]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_raster_columns](
	[rastercolumn_id] [int] NOT NULL,
	[description] [nvarchar](65) NULL,
	[database_name] [nvarchar](32) NOT NULL,
	[owner] [nvarchar](32) NOT NULL,
	[table_name] [sysname] NOT NULL,
	[raster_column] [nvarchar](32) NOT NULL,
	[cdate] [int] NOT NULL,
	[config_keyword] [nvarchar](32) NULL,
	[minimum_id] [int] NULL,
	[base_rastercolumn_id] [int] NOT NULL,
	[rastercolumn_mask] [int] NOT NULL,
	[srid] [int] NULL,
 CONSTRAINT [rascol_pk] PRIMARY KEY CLUSTERED 
(
	[database_name] ASC,
	[owner] ASC,
	[table_name] ASC,
	[raster_column] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY],
 CONSTRAINT [rascol_uk] UNIQUE NONCLUSTERED 
(
	[rastercolumn_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[i7_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i7_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i7 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i7 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i7 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i7_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i7_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i7 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i7 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i7 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i7 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i7
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i7 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i7 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i69_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i69_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i69 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i69 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i69 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i69_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i69_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i69 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i69 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i69 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i69 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i69
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i69 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i69 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i68_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i68_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i68 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i68 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i68 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i68_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i68_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i68 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i68 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i68 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i68 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i68
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i68 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i68 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i62_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i62_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i62 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i62 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i62 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i62_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i62_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i62 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i62 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i62 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i62 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i62
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i62 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i62 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i61_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i61_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i61 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i61 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i61 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i61_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i61_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i61 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i61 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i61 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i61 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i61
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i61 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i61 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i60_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i60_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i60 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i60 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i60 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i60_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i60_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i60 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i60 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i60 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i60 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i60
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i60 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i60 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i6_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i6_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i6 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i6 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i6 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i6_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i6_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i6 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i6 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i6 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i6 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i6
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i6 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i6 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i59_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i59_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i59 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i59 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i59 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i59_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i59_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i59 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i59 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i59 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i59 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i59
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i59 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i59 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i58_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i58_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i58 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i58 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i58 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i58_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i58_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i58 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i58 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i58 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i58 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i58
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i58 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i58 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i57_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i57_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i57 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i57 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i57 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i57_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i57_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i57 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i57 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i57 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i57 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i57
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i57 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i57 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i56_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i56_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i56 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i56 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i56 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i56_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i56_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i56 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i56 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i56 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i56 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i56
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i56 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i56 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i55_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i55_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i55 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i55 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i55 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i55_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i55_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i55 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i55 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i55 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i55 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i55
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i55 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i55 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i54_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i54_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i54 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i54 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i54 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i54_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i54_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i54 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i54 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i54 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i54 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i54
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i54 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i54 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i53_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i53_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i53 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i53 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i53 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i53_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i53_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i53 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i53 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i53 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i53 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i53
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i53 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i53 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i52_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i52_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i52 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i52 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i52 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i52_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i52_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i52 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i52 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i52 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i52 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i52
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i52 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i52 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i51_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i51_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i51 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i51 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i51 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i51_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i51_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i51 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i51 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i51 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i51 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i51
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i51 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i51 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i50_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i50_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i50 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i50 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i50 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i50_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i50_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i50 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i50 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i50 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i50 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i50
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i50 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i50 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i5_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i5_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i5 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i5 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i5 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i5_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i5_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i5 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i5 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i5 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i5 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i5
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i5 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i5 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i48_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i48_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i48 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i48 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i48 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i48_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i48_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i48 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i48 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i48 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i48 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i48
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i48 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i48 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i46_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i46_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i46 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i46 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i46 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i46_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i46_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i46 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i46 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i46 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i46 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i46
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i46 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i46 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i45_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i45_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i45 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i45 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i45 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i45_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i45_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i45 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i45 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i45 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i45 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i45
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i45 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i45 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i44_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i44_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i44 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i44 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i44 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i44_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i44_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i44 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i44 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i44 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i44 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i44
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i44 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i44 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i43_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i43_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i43 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i43 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i43 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i43_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i43_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i43 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i43 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i43 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i43 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i43
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i43 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i43 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i42_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i42_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i42 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i42 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i42 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i42_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i42_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i42 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i42 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i42 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i42 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i42
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i42 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i42 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i41_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i41_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i41 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i41 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i41 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i41_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i41_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i41 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i41 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i41 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i41 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i41
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i41 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i41 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i40_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i40_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i40 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i40 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i40 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i40_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i40_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i40 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i40 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i40 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i40 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i40
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i40 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i40 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i4_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i4_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i4 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i4 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i4 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i4_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i4_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i4 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i4 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i4 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i4 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i4
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i4 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i4 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i39_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i39_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i39 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i39 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i39 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i39_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i39_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i39 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i39 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i39 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i39 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i39
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i39 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i39 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i38_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i38_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i38 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i38 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i38 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i38_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i38_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i38 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i38 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i38 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i38 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i38
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i38 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i38 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i37_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i37_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i37 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i37 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i37 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i37_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i37_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i37 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i37 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i37 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i37 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i37
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i37 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i37 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i35_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i35_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i35 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i35 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i35 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i35_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i35_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i35 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i35 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i35 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i35 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i35
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i35 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i35 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i34_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i34_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i34 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i34 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i34 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i34_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i34_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i34 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i34 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i34 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i34 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i34
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i34 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i34 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i32_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i32_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i32 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i32 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i32 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i32_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i32_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i32 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i32 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i32 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i32 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i32
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i32 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i32 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i31_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i31_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i31 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i31 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i31 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i31_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i31_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i31 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i31 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i31 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i31 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i31
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i31 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i31 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i30_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i30_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i30 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i30 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i30 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i30_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i30_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i30 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i30 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i30 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i30 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i30
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i30 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i30 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i3_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i3_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i3 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i3 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i3 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i3_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i3_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i3 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i3 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i3 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i3 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i3
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i3 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i3 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i29_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i29_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i29 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i29 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i29 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i29_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i29_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i29 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i29 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i29 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i29 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i29
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i29 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i29 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i25_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i25_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i25 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i25 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i25 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i25_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i25_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i25 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i25 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i25 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i25 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i25
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i25 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i25 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i24_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i24_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i24 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i24 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i24 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i24_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i24_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i24 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i24 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i24 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i24 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i24
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i24 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i24 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i23_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i23_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i23 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i23 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i23 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i23_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i23_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i23 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i23 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i23 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i23 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i23
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i23 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i23 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i22_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i22_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i22 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i22 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i22 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i22_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i22_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i22 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i22 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i22 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i22 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i22
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i22 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i22 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i21_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i21_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i21 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i21 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i21 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i21_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i21_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i21 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i21 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i21 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i21 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i21
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i21 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i21 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i20_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i20_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i20 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i20 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i20 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i20_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i20_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i20 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i20 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i20 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i20 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i20
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i20 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i20 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i2_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i2_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i2 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i2 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i2 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i2_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i2_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i2 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i2 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i2 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i2 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i2
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i2 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i2 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i19_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i19_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i19 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i19 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i19 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i19_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i19_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i19 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i19 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i19 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i19 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i19
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i19 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i19 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i18_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i18_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i18 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i18 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i18 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i18_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i18_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i18 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i18 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i18 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i18 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i18
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i18 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i18 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i17_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i17_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i17 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i17 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i17 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i17_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i17_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i17 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i17 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i17 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i17 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i17
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i17 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i17 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i16_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i16_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i16 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i16 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i16 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i16_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i16_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i16 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i16 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i16 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i16 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i16
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i16 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i16 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  Table [dbo].[DEM_30M]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[DEM_30M](
	[OBJECTID] [int] NOT NULL,
	[Name] [nvarchar](256) NULL,
	[Shape] [geometry] NULL,
	[Raster] [int] NULL,
 CONSTRAINT [R69_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S31_idx] ON [dbo].[DEM_30M] 
(
	[Shape]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [sde_rix_5] ON [dbo].[DEM_30M] 
(
	[Raster] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[GDB_ITEMS]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [dbo].[GDB_ITEMS](
	[ObjectID] [int] NOT NULL,
	[UUID] [uniqueidentifier] NOT NULL,
	[Type] [uniqueidentifier] NOT NULL,
	[Name] [nvarchar](226) NULL,
	[PhysicalName] [nvarchar](226) NULL,
	[Path] [nvarchar](512) NULL,
	[Url] [nvarchar](255) NULL,
	[Properties] [int] NULL,
	[Defaults] [varbinary](max) NULL,
	[DatasetSubtype1] [int] NULL,
	[DatasetSubtype2] [int] NULL,
	[DatasetInfo1] [nvarchar](255) NULL,
	[DatasetInfo2] [nvarchar](255) NULL,
	[Definition] [xml] NULL,
	[Documentation] [xml] NULL,
	[ItemInfo] [xml] NULL,
	[Shape] [geometry] NULL,
 CONSTRAINT [R2_pk] PRIMARY KEY CLUSTERED 
(
	[ObjectID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [GDB_Items_UUID_idx] ON [dbo].[GDB_ITEMS] 
(
	[UUID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [Items_Name_idx] ON [dbo].[GDB_ITEMS] 
(
	[Name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [Items_PhysicalName_idx] ON [dbo].[GDB_ITEMS] 
(
	[PhysicalName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [Items_Type_idx] ON [dbo].[GDB_ITEMS] 
(
	[Type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
SET ANSI_PADDING ON
CREATE SPATIAL INDEX [S1_idx] ON [dbo].[GDB_ITEMS] 
(
	[Shape]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE PRIMARY XML INDEX [xmlprim_Definition] ON [dbo].[GDB_ITEMS] 
(
	[Definition]
)WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE PRIMARY XML INDEX [xmlprim_Documentation] ON [dbo].[GDB_ITEMS] 
(
	[Documentation]
)WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE PRIMARY XML INDEX [xmlprim_ItemInfo] ON [dbo].[GDB_ITEMS] 
(
	[ItemInfo]
)WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE XML INDEX [xmlpath_Definition] ON [dbo].[GDB_ITEMS] 
(
	[Definition]
)
USING XML INDEX [xmlprim_Definition] FOR PATH WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE XML INDEX [xmlpath_Documentation] ON [dbo].[GDB_ITEMS] 
(
	[Documentation]
)
USING XML INDEX [xmlprim_Documentation] FOR PATH WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE XML INDEX [xmlpath_ItemInfo] ON [dbo].[GDB_ITEMS] 
(
	[ItemInfo]
)
USING XML INDEX [xmlprim_ItemInfo] FOR PATH WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE XML INDEX [xmlval_Definition] ON [dbo].[GDB_ITEMS] 
(
	[Definition]
)
USING XML INDEX [xmlprim_Definition] FOR VALUE WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE XML INDEX [xmlval_Documentation] ON [dbo].[GDB_ITEMS] 
(
	[Documentation]
)
USING XML INDEX [xmlprim_Documentation] FOR VALUE WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE XML INDEX [xmlval_ItemInfo] ON [dbo].[GDB_ITEMS] 
(
	[ItemInfo]
)
USING XML INDEX [xmlprim_ItemInfo] FOR VALUE WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
/****** Object:  Table [dbo].[GDB_ITEMRELATIONSHIPTYPES]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[GDB_ITEMRELATIONSHIPTYPES](
	[ObjectID] [int] NOT NULL,
	[UUID] [uniqueidentifier] NOT NULL,
	[Name] [nvarchar](226) NOT NULL,
	[ForwardLabel] [nvarchar](226) NULL,
	[BackwardLabel] [nvarchar](226) NULL,
	[OrigItemTypeID] [uniqueidentifier] NOT NULL,
	[DestItemTypeID] [uniqueidentifier] NOT NULL,
	[IsContainment] [int] NULL
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [ItmRTypes_BackwardLabel_idx] ON [dbo].[GDB_ITEMRELATIONSHIPTYPES] 
(
	[BackwardLabel] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [ItmRTypes_DestItemTypeID_idx] ON [dbo].[GDB_ITEMRELATIONSHIPTYPES] 
(
	[DestItemTypeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [ItmRTypes_ForwardLabel_idx] ON [dbo].[GDB_ITEMRELATIONSHIPTYPES] 
(
	[ForwardLabel] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [ItmRTypes_Name_idx] ON [dbo].[GDB_ITEMRELATIONSHIPTYPES] 
(
	[Name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [ItmRTypes_OrigItemTypeID_idx] ON [dbo].[GDB_ITEMRELATIONSHIPTYPES] 
(
	[OrigItemTypeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [ItmRTypes_UUID_idx] ON [dbo].[GDB_ITEMRELATIONSHIPTYPES] 
(
	[UUID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [R5_SDE_ROWID_UK] ON [dbo].[GDB_ITEMRELATIONSHIPTYPES] 
(
	[ObjectID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[GDB_ITEMRELATIONSHIPS]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[GDB_ITEMRELATIONSHIPS](
	[ObjectID] [int] NOT NULL,
	[UUID] [uniqueidentifier] NOT NULL,
	[Type] [uniqueidentifier] NOT NULL,
	[OriginID] [uniqueidentifier] NOT NULL,
	[DestID] [uniqueidentifier] NOT NULL,
	[Properties] [int] NULL,
	[Attributes] [xml] NULL,
 CONSTRAINT [R3_pk] PRIMARY KEY CLUSTERED 
(
	[ObjectID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [GDB_ItemRel_DestID_idx] ON [dbo].[GDB_ITEMRELATIONSHIPS] 
(
	[DestID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [GDB_ItemRel_OriginID_idx] ON [dbo].[GDB_ITEMRELATIONSHIPS] 
(
	[OriginID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [GDB_ItemRel_Type_idx] ON [dbo].[GDB_ITEMRELATIONSHIPS] 
(
	[Type] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [GDB_ItemRelationships_UUID_idx] ON [dbo].[GDB_ITEMRELATIONSHIPS] 
(
	[UUID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE PRIMARY XML INDEX [xmlprim_Attributes] ON [dbo].[GDB_ITEMRELATIONSHIPS] 
(
	[Attributes]
)WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE XML INDEX [xmlpath_Attributes] ON [dbo].[GDB_ITEMRELATIONSHIPS] 
(
	[Attributes]
)
USING XML INDEX [xmlprim_Attributes] FOR PATH WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF
CREATE XML INDEX [xmlval_Attributes] ON [dbo].[GDB_ITEMRELATIONSHIPS] 
(
	[Attributes]
)
USING XML INDEX [xmlprim_Attributes] FOR VALUE WITH (PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON)
GO
/****** Object:  Table [dbo].[GDB_REPLICALOG]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[GDB_REPLICALOG](
	[ID] [int] NOT NULL,
	[ReplicaID] [int] NOT NULL,
	[Event] [int] NOT NULL,
	[ErrorCode] [int] NOT NULL,
	[LogDate] [datetime2](7) NOT NULL,
	[SourceBeginGen] [int] NOT NULL,
	[SourceEndGen] [int] NOT NULL,
	[TargetGen] [int] NOT NULL
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [R6_SDE_ROWID_UK] ON [dbo].[GDB_REPLICALOG] 
(
	[ID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[i15_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i15_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i15 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i15 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i15 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i15_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i15_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i15 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i15 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i15 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i15 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i15
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i15 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i15 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i14_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i14_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i14 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i14 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i14 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i14_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i14_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i14 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i14 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i14 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i14 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i14
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i14 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i14 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i13_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i13_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i13 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i13 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i13 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i13_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i13_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i13 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i13 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i13 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i13 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i13
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i13 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i13 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i12_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i12_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i12 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i12 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i12 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i12_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i12_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i12 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i12 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i12 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i12 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i12
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i12 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i12 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i11_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i11_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i11 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i11 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i11 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i11_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i11_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i11 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i11 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i11 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i11 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i11
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i11 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i11 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  StoredProcedure [dbo].[i10_return_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i10_return_ids]
@id_type integer,
@base_id integer,
@num_ids integer
AS SET NOCOUNT ON
BEGIN
  DECLARE @last_id integer
  DECLARE @fetched_base_id integer
  BEGIN TRAN id_tran
  SELECT @last_id = last_id, @fetched_base_id = base_id
    FROM FORDATA_{1}.DBO.i10 WITH (tablockx, holdlock)
    WHERE num_ids = -1 AND id_type = @id_type
  IF ( (@last_id < @base_id) AND
       ((@base_id + @num_ids) = @fetched_base_id))
  BEGIN
    /* only return ids if no one else has grabbed a block
       and were returning the remainder of the block. */
    UPDATE FORDATA_{1}.DBO.i10 SET base_id = @base_id
       WHERE num_ids = -1 AND id_type = @id_type
  END
  ELSE
  BEGIN
    /* Insert a new fragment */
    INSERT INTO FORDATA_{1}.DBO.i10 (base_id, num_ids, id_type)
      VALUES (@base_id, @num_ids, @id_type)
  END
  COMMIT TRAN id_tran /* releases holdlock table lock */
END
GO
/****** Object:  StoredProcedure [dbo].[i10_get_ids]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[i10_get_ids]
@id_type integer,
@num_requested_ids integer,
@base_id integer OUTPUT,
@num_obtained_ids integer OUTPUT AS SET NOCOUNT ON
BEGIN
  IF (@num_requested_ids < 0)
  BEGIN 
    BEGIN TRAN id_tran
    /* We are resetting the generator. */
    /* Delete fragments and update the base value.*/
    UPDATE FORDATA_{1}.DBO.i10 WITH  (tablockx, holdlock)
      SET base_id = base_id + @num_requested_ids
      WHERE num_ids = -1 AND id_type = @id_type
    DELETE FROM FORDATA_{1}.DBO.i10 WHERE id_type = @id_type and num_ids <> -1
    COMMIT TRAN id_tran /* releases holdlock table lock */
  END
  ELSE
  BEGIN
    IF (@num_requested_ids > 0)
    BEGIN
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i10 WITH (tablockx, holdlock)
        WHERE id_type = @id_type
        ORDER BY num_ids DESC /* ensures that fragments come first */
        FOR UPDATE /* to get a lock */
    END
    ELSE
    BEGIN
      /* only interested in base id */
      DECLARE I_cursor CURSOR FOR
        SELECT base_id, num_ids
        FROM FORDATA_{1}.DBO.i10 WITH (tablockx, holdlock)
        WHERE id_type = @id_type AND num_ids = -1
        FOR UPDATE /* to get a lock */
    END
    BEGIN TRAN id_tran
    OPEN I_cursor
    FETCH NEXT FROM I_cursor INTO @base_id, @num_obtained_ids
    IF (@num_requested_ids = 0)
    BEGIN
      /* Just getting current value */
      SET @num_obtained_ids = 0
    END
    ELSE
    BEGIN
      IF (@num_obtained_ids = -1)
      BEGIN
        /* user got the amount they wanted */
        SET @num_obtained_ids = @num_requested_ids
        /* update the last id and base id */
        UPDATE FORDATA_{1}.DBO.i10
          SET base_id = base_id + @num_obtained_ids,
              last_id =  @base_id
          WHERE CURRENT OF I_cursor
      END
      ELSE
      BEGIN
        /* user got a fragment */
        IF (@num_requested_ids = 1) AND (@num_obtained_ids > 1)
        BEGIN
          /* they want one and exactly one id */
          SET @num_obtained_ids = 1
          UPDATE FORDATA_{1}.DBO.i10 SET base_id = base_id + 1,
            num_ids =  num_ids - 1 WHERE CURRENT OF I_cursor
        END
        ELSE
        BEGIN
          /* Return the whole fragment, delete the the row */
          DELETE FROM FORDATA_{1}.DBO.i10 WHERE CURRENT OF I_cursor
        END
      END
    END
    CLOSE I_cursor
    COMMIT TRAN id_tran /* releases holdlock table lock */
    DEALLOCATE I_cursor
  END
END
GO
/****** Object:  Table [dbo].[HILLSHADE_30M]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[HILLSHADE_30M](
	[OBJECTID] [int] NOT NULL,
	[Name] [nvarchar](256) NULL,
	[Shape] [geometry] NULL,
	[Raster] [int] NULL,
 CONSTRAINT [R68_pk] PRIMARY KEY CLUSTERED 
(
	[OBJECTID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE SPATIAL INDEX [S30_idx] ON [dbo].[HILLSHADE_30M] 
(
	[Shape]
)USING  GEOMETRY_GRID 
WITH (
BOUNDING_BOX =(-400, -90, 400, 90), GRIDS =(LEVEL_1 = MEDIUM,LEVEL_2 = MEDIUM,LEVEL_3 = MEDIUM,LEVEL_4 = MEDIUM), 
CELLS_PER_OBJECT = 16, PAD_INDEX  = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [sde_rix_4] ON [dbo].[HILLSHADE_30M] 
(
	[Raster] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Table [dbo].[GDB_ITEMTYPES]    Script Date: 03/19/2014 09:13:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[GDB_ITEMTYPES](
	[ObjectID] [int] NOT NULL,
	[UUID] [uniqueidentifier] NOT NULL,
	[Name] [nvarchar](226) NOT NULL,
	[ParentTypeID] [uniqueidentifier] NOT NULL
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [ItemTypes_Name_idx] ON [dbo].[GDB_ITEMTYPES] 
(
	[Name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [ItemTypes_ParentTypeID_idx] ON [dbo].[GDB_ITEMTYPES] 
(
	[ParentTypeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [ItemTypes_UUID_idx] ON [dbo].[GDB_ITEMTYPES] 
(
	[UUID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [R4_SDE_ROWID_UK] ON [dbo].[GDB_ITEMTYPES] 
(
	[ObjectID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
GO
/****** Object:  Trigger [GDB_ITEMS_TAB_TR]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[GDB_ITEMS_TAB_TR] ON [dbo].[GDB_ITEMS] FOR INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON UPDATE dbo.GDB_TABLES_LAST_MODIFIED SET last_modified_count = last_modified_count + 1 WHERE table_name = 'GDB_ITEMS' IF @@ROWCOUNT = 0 BEGIN INSERT INTO dbo.GDB_TABLES_LAST_MODIFIED VALUES ('GDB_ITEMS', 1) END END
GO
/****** Object:  Trigger [GDB_ITEMS_REL_TR]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[GDB_ITEMS_REL_TR] ON [dbo].[GDB_ITEMRELATIONSHIPS] FOR INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON UPDATE dbo.GDB_TABLES_LAST_MODIFIED SET last_modified_count = last_modified_count + 1 WHERE table_name = 'GDB_ITEMRELATIONSHIPS' IF @@ROWCOUNT = 0 BEGIN INSERT INTO dbo.GDB_TABLES_LAST_MODIFIED VALUES ('GDB_ITEMRELATIONSHIPS', 1) END END
GO
/****** Object:  Trigger [GDB_REP_LOG_TR]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[GDB_REP_LOG_TR] ON [dbo].[GDB_REPLICALOG] FOR INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON UPDATE dbo.GDB_TABLES_LAST_MODIFIED SET last_modified_count = last_modified_count + 1 WHERE table_name = 'GDB_REPLICALOG' IF @@ROWCOUNT = 0 BEGIN INSERT INTO dbo.GDB_TABLES_LAST_MODIFIED VALUES ('GDB_REPLICALOG', 1) END END
GO
/****** Object:  Trigger [GDB_ITEM_TYP_TR]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[GDB_ITEM_TYP_TR] ON [dbo].[GDB_ITEMTYPES] FOR INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON UPDATE dbo.GDB_TABLES_LAST_MODIFIED SET last_modified_count = last_modified_count + 1 WHERE table_name = 'GDB_ITEMTYPES' IF @@ROWCOUNT = 0 BEGIN INSERT INTO dbo.GDB_TABLES_LAST_MODIFIED VALUES ('GDB_ITEMTYPES', 1) END END
GO
/****** Object:  Trigger [GDB_ITEM_REL_TYP_TR]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[GDB_ITEM_REL_TYP_TR] ON [dbo].[GDB_ITEMRELATIONSHIPTYPES] FOR INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON UPDATE dbo.GDB_TABLES_LAST_MODIFIED SET last_modified_count = last_modified_count + 1 WHERE table_name = 'GDB_ITEMRELATIONSHIPTYPES' IF @@ROWCOUNT = 0 BEGIN INSERT INTO dbo.GDB_TABLES_LAST_MODIFIED VALUES ('GDB_ITEMRELATIONSHIPTYPES', 1) END END
GO
/****** Object:  StoredProcedure [dbo].[SDE_rascol_srid_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_rascol_srid_update]              @sridVal INTEGER, @rastercolumn_idVal INTEGER AS             SET NOCOUNT ON UPDATE FORDATA_{1}.dbo.SDE_raster_columns               SET srid = @sridVal WHERE rastercolumn_id = @rastercolumn_idVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_rascol_spatial_reference_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_rascol_spatial_reference_update]             @rastercolumn_idVal INTEGER, @srTextVal TEXT,            @xycluster_tolVal FLOAT,            @zcluster_tolVal FLOAT, @mcluster_tolVal FLOAT AS            SET NOCOUNT ON UPDATE FORDATA_{1}.dbo.SDE_spatial_references SET             srtext = @srTextVal, xycluster_tol = @xycluster_tolVal,            zcluster_tol = @zcluster_tolVal, mcluster_tol = @mcluster_tolVal            WHERE srid  in (SELECT srid from FORDATA_{1}.dbo.SDE_raster_columns             WHERE rastercolumn_id = @rastercolumn_idVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_rascol_def_update_migrate]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_rascol_def_update_migrate] @rastercolumn_idVal INTEGER,      @descriptionVal NVARCHAR(65), @config_keywordVal NVARCHAR(32),       @minimum_idVal INTEGER, @rastercolumn_maskVal INTEGER,       @raster_columnVal NVARCHAR(32)       AS SET NOCOUNT ON UPDATE FORDATA_{1}.dbo.SDE_raster_columns SET description = @descriptionVal,      config_keyword = @config_keywordVal,       minimum_id = @minimum_idVal, rastercolumn_mask = @rastercolumn_maskVal,       raster_column = @raster_columnVal       WHERE rastercolumn_id = @rastercolumn_idVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_rascol_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_rascol_def_update] @rastercolumn_idVal INTEGER,      @descriptionVal NVARCHAR(65), @config_keywordVal NVARCHAR(32),       @minimum_idVal INTEGER, @rastercolumn_maskVal INTEGER      AS SET NOCOUNT ON UPDATE FORDATA_{1}.dbo.SDE_raster_columns SET description = @descriptionVal,      config_keyword = @config_keywordVal,       minimum_id = @minimum_idVal, rastercolumn_mask = @rastercolumn_maskVal       WHERE rastercolumn_id = @rastercolumn_idVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_rascol_def_rename]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_rascol_def_rename] @table_nameVal sysname,      @rastercolumn_idVal INTEGER       AS SET NOCOUNT ON UPDATE FORDATA_{1}.dbo.SDE_raster_columns SET table_name = @table_nameVal       WHERE rastercolumn_id = @rastercolumn_idVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_rascol_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_rascol_def_insert]       @rastercolumn_idVal INTEGER,@descriptionVal NVARCHAR(65),       @database_nameVal NVARCHAR(32),@ownerVal NVARCHAR(32), @table_nameVal sysname,      @raster_columnVal NVARCHAR(32), @cdateVal INTEGER,       @config_keywordVal NVARCHAR(32), @minimum_idVal INTEGER, @base_idVal INTEGER,       @rastercolumn_maskVal INTEGER, @sridVal INTEGER AS SET NOCOUNT ON      INSERT INTO FORDATA_{1}.dbo.SDE_raster_columns       (rastercolumn_id,description,database_name,owner,table_name,raster_column,      cdate,config_keyword,minimum_id,base_rastercolumn_id, rastercolumn_mask,srid) VALUES       (@rastercolumn_idVal,@descriptionVal,@database_nameVal,@ownerVal,       @table_nameVal,@raster_columnVal,@cdateVal,@config_keywordVal,       @minimum_idVal,@base_idVal,@rastercolumn_maskVal,@sridVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_rascol_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_rascol_def_delete] @rascol_idVal        INTEGER AS SET NOCOUNT ON DELETE FROM FORDATA_{1}.dbo.SDE_raster_columns WHERE rastercolumn_id =       @rascol_idVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_purge_processes]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_purge_processes] AS SET NOCOUNT ON
BEGIN
  BEGIN TRAN pinfo_tran
  DECLARE process_cursor CURSOR LOCAL FAST_FORWARD FOR
    SELECT PR.sde_id, SO.object_id
    FROM FORDATA_{1}.dbo.SDE_process_information PR WITH  (TABLOCK,XLOCK,HOLDLOCK)
      LEFT JOIN tempdb.sys.objects SO
      ON object_id (PR.table_name) = SO.object_id
  OPEN process_cursor
  DECLARE @sde_id INTEGER
  DECLARE @table_id INTEGER
  FETCH NEXT FROM process_cursor INTO @sde_id,@table_id
  WHILE @@FETCH_STATUS = 0
    BEGIN
    IF (@table_id IS NULL)
    BEGIN
      /* We found an invalid connection, clean it up. */
      EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @sde_id
    END
    FETCH NEXT FROM process_cursor INTO @sde_id,@table_id
  END /* while */
  CLOSE process_cursor
  DEALLOCATE process_cursor
  COMMIT TRAN pinfo_tran
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_pinfo_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_pinfo_def_insert]
 @sdeIdVal INTEGER,
  @serverIdVal INTEGER,
 @directConnectVal VARCHAR(1),
 @sysnameVal NVARCHAR(32),
 @nodenameVal NVARCHAR(256),
 @xdrneededVal VARCHAR(1),
 @tablenameVal NVARCHAR(95) AS SET NOCOUNT ON
 BEGIN TRAN pinfo_tran
 DECLARE @current_user NVARCHAR(30)
 DECLARE process_cursor CURSOR LOCAL FAST_FORWARD FOR 
 SELECT sde_id FROM FORDATA_{1}.dbo.SDE_process_information WITH  (TABLOCK,XLOCK,HOLDLOCK) 
 WHERE spid = @@spid and table_name <> @tablenameVal 
 OPEN process_cursor 
 DECLARE @sde_id INTEGER
 FETCH NEXT FROM process_cursor INTO @sde_id
 WHILE @@FETCH_STATUS = 0
  BEGIN
  /* We found an invalid connection, clean it up. */ 
  EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @sde_id
  FETCH NEXT FROM process_cursor INTO @sde_id
  END /* while */ 
 CLOSE process_cursor
 DEALLOCATE process_cursor
 EXECUTE FORDATA_{1}.dbo.SDE_get_current_user_name @current_user OUTPUT
 INSERT INTO FORDATA_{1}.dbo.SDE_process_information (sde_id,spid,server_id,start_time,
    rcount,wcount,opcount,numlocks,fb_partial,fb_count,fb_fcount,
    fb_kbytes,owner,direct_connect,sysname,nodename,xdr_needed,table_name)
 VALUES (@sdeIdVal,@@spid,@serverIdVal,getdate(),0,0,0,0,0,0,0,0,
    @current_user,@directConnectVal,@sysnameVal,@nodenameVal,
    @xdrneededVal,@tablenameVal)
 DELETE FROM FORDATA_{1}.dbo.SDE_lineages_modified 
    WHERE DATEDIFF (day, time_last_modified, getdate()) > 2
 COMMIT TRAN pinfo_tran
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_check_lock_conflicts]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_check_lock_conflicts]
@sdeIdVal INTEGER,
@stateIdVal BIGINT,
@autoLockVal VARCHAR(1),
@lockTypeVal VARCHAR(1),
@lock_conflict INTEGER OUTPUT AS SET NOCOUNT ON
BEGIN
  DECLARE locks_cursor CURSOR LOCAL FAST_FORWARD FOR
    SELECT sde_id
    FROM   FORDATA_{1}.dbo.SDE_state_locks WITH (TABLOCKX,HOLDLOCK)
    WHERE ((state_id = @stateIdVal AND
           (sde_id <> @sdeIdVal OR 
            autolock = @autoLockVal) AND
           (lock_type = 'E' /* E: Exclusive lock */ OR 
            @lockTypeVal = 'E')) OR
          (lock_type = 'X' /* X: Exclusive lock all */ OR
           @lockTypeVal = 'X')) AND
          lock_type <> 'M'
  /* Find any conflicting locks.  The query we use is sensitive about
     whether we are trying to place an exclusive lock (in which case we
     have to consider all locks as possibly conflicting), or a shared lock
     (in which case we only have to worry about conflicting with exclusive
     locks).  With all of the about constraints in place, if any rows
     are returned, we probably have a conflict.  The last thing we have to
     check is if the connection owning the lock has somehow died without
     cleaning up. */
  OPEN locks_cursor
  DECLARE @loop_done INTEGER
  DECLARE @id INTEGER
  SET @lock_conflict = 0
  SET @loop_done = 0
  DECLARE @f_sde_id INTEGER
  WHILE @loop_done = 0
  BEGIN 
    FETCH NEXT FROM locks_cursor INTO @f_sde_id
    IF @@FETCH_STATUS = 0
    BEGIN
      /* We found a matching table lock.  See if the owning connection
         id is still out there.  If not, then this lock is invalid. */

      SELECT @id = SO.object_id
        FROM tempdb.sys.objects SO INNER JOIN
            FORDATA_{1}.dbo.SDE_process_information        PR ON object_id (PR.table_name) = SO.object_id
        WHERE PR.sde_id = @f_sde_id

      IF @@ROWCOUNT > 0
      BEGIN
        /* we have a lock conflict! */
        SET @lock_conflict = 1
        SET @loop_done = 1
      END
      ELSE
      BEGIN
         /* defunct connection found, clean it up */
         EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @f_sde_id
      END
     END
     ELSE
       SET @loop_done = 1
  END /* while */
  CLOSE locks_cursor
  DEALLOCATE locks_cursor
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_def_update]
@stateIdVal BIGINT, @OpenOrCloseVal INTEGER,
@clTimeVal DATETIME OUTPUT AS SET NOCOUNT ON 
BEGIN
DECLARE @closeTimeVal DATETIME
SET @clTimeVal = GETDATE()
IF @OpenOrCloseVal = 2
BEGIN
  SET @closeTimeVal = @clTimeVal
END
ELSE
BEGIN
  SET @closeTimeVal = NULL
END
BEGIN TRAN state_def_update
UPDATE FORDATA_{1}.dbo.SDE_states SET closing_time = @closeTimeVal
  WHERE state_id = @stateIdVal
COMMIT TRAN state_def_update
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_def_trim_states]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_def_trim_states]
@highStateIdVal BIGINT, @lowStateIdVal BIGINT AS SET NOCOUNT ON
BEGIN
  IF @lowStateIdVal = 0
  BEGIN
    -- Uninvert the inverted lineage names; once the delete is done
    -- it is safe to put them back. Make sure to use RC so that
    -- we don't update another process's negative lineages.
    UPDATE FORDATA_{1}.dbo.SDE_states WITH (READCOMMITTED)
    SET    lineage_name = -lineage_name
    WHERE  lineage_name < 0 AND parent_state_id = 0
  END
  ELSE
  BEGIN
    -- Return the lineage id to a positive number.
    UPDATE FORDATA_{1}.dbo.SDE_states
    SET    lineage_name = -lineage_name
    WHERE  state_id = @highStateIdVal
  END
END
GO
/****** Object:  Trigger [sde_lineage_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[sde_lineage_delete] ON [FORDATA_{1}].[dbo].[SDE_states] FOR DELETE AS      DELETE FROM FORDATA_{1}.dbo.SDE_state_lineages WHERE lineage_id IN (SELECT state_id FROM deleted)
GO
/****** Object:  Table [dbo].[SDE_layer_stats]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_layer_stats](
	[oid] [int] IDENTITY(1,1) NOT NULL,
	[layer_id] [int] NOT NULL,
	[version_id] [int] NULL,
	[minx] [float] NOT NULL,
	[miny] [float] NOT NULL,
	[maxx] [float] NOT NULL,
	[maxy] [float] NOT NULL,
	[minz] [float] NULL,
	[minm] [float] NULL,
	[maxz] [float] NULL,
	[maxm] [float] NULL,
	[total_features] [int] NOT NULL,
	[total_points] [int] NOT NULL,
	[last_analyzed] [datetime] NOT NULL,
 CONSTRAINT [sdelayer_stats_pk] PRIMARY KEY CLUSTERED 
(
	[oid] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY],
 CONSTRAINT [sdelayer_stats_uk] UNIQUE NONCLUSTERED 
(
	[layer_id] ASC,
	[version_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_srid_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_srid_update]              @sridVal INTEGER, @layeridVal INTEGER AS SET NOCOUNT ON BEGIN              DECLARE @g_table sysname              SET @g_table = N'f' + cast(@layeridVal as NVARCHAR)              UPDATE FORDATA_{1}.dbo.SDE_layers SET srid = @sridVal WHERE layer_id = @layeridVal 
 UPDATE             FORDATA_{1}.dbo.SDE_geometry_columns SET srid = @sridVal WHERE g_table_name = @g_table END
GO
/****** Object:  StoredProcedure [dbo].[SDE_object_check_lock_conflicts]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_object_check_lock_conflicts]
@sdeIdVal INTEGER,
@objectIdVal INTEGER,
@objectTypeVal INTEGER,
@applicationIdVal INTEGER,
@autoLockVal VARCHAR(1),
@lockTypeVal VARCHAR(1),
@lock_conflict INTEGER OUTPUT AS SET NOCOUNT ON
BEGIN
  DECLARE locks_cursor CURSOR LOCAL FAST_FORWARD FOR
    SELECT sde_id
    FROM   FORDATA_{1}.dbo.SDE_object_locks WITH (TABLOCKX,HOLDLOCK)
    WHERE  object_id = @objectIdVal AND
           object_type = @objectTypeVal AND
           application_id = @applicationIdVal AND
           (sde_id <> @sdeIdVal OR
            autolock = @autoLockVal) AND
           (lock_type = 'E' /* E: Exclusive lock */ OR 
            @lockTypeVal = 'E')
  /* Find any conflicting locks.  The query we use is sensitive about
     whether we are trying to place an exclusive lock (in which case we
     have to consider all locks as possibly conflicting), or a shared lock
     (in which case we only have to worry about conflicting with exclusive
     locks).  With all of the about constraints in place, if any rows
     are returned, we probably have a conflict.  The last thing we have to
     check is if the connection owning the lock has somehow died without
     cleaning up. */
  OPEN locks_cursor
  DECLARE @loop_done INTEGER
  DECLARE @id INTEGER
  SET @lock_conflict = 0
  SET @loop_done = 0
  DECLARE @f_sde_id INTEGER
  WHILE @loop_done = 0
  BEGIN 
    FETCH NEXT FROM locks_cursor INTO @f_sde_id
    IF @@FETCH_STATUS = 0
    BEGIN
      /* We found a matching table lock.  See if the owning connection
         id is still out there.  If not, then this lock is invalid. */

      SELECT @id = SO.object_id
        FROM tempdb.sys.objects SO INNER JOIN
            FORDATA_{1}.dbo.SDE_process_information        PR ON object_id (PR.table_name) = SO.object_id
        WHERE PR.sde_id = @f_sde_id

      IF @@ROWCOUNT > 0
      BEGIN
        /* we have a lock conflict! */
        SET @lock_conflict = 1
        SET @loop_done = 1
      END
      ELSE
      BEGIN
         /* defunct connection found, clean it up */
         EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @f_sde_id
      END
     END
     ELSE
       SET @loop_done = 1
  END /* while */
  CLOSE locks_cursor
  DEALLOCATE locks_cursor
END
GO
/****** Object:  Table [dbo].[SDE_mvtables_modified]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[SDE_mvtables_modified](
	[state_id] [bigint] NOT NULL,
	[registration_id] [int] NOT NULL,
 CONSTRAINT [mvtables_modified_pk] PRIMARY KEY CLUSTERED 
(
	[state_id] ASC,
	[registration_id] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 75) ON [PRIMARY]
) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[SDE_geocol_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_geocol_def_update]             @layerIdVal INTEGER, @srTextVal TEXT, @xycluster_tolVal FLOAT,            @zcluster_tolVal FLOAT, @mcluster_tolVal FLOAT AS SET NOCOUNT ON            UPDATE FORDATA_{1}.dbo.SDE_spatial_references SET srtext = @srTextVal,            xycluster_tol = @xycluster_tolVal, zcluster_tol = @zcluster_tolVal,            mcluster_tol = @mcluster_tolVal WHERE srid  in (SELECT srid            FROM FORDATA_{1}.dbo.SDE_layers WHERE layer_id = @layerIdVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_geocol_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_geocol_def_insert] @fTabCatVal NVARCHAR(32),     @fTabSchVal NVARCHAR(32), @fTabNameVal sysname, @fGeoColVal NVARCHAR(32), @gTabCatVal     NVARCHAR(32), @gTabSchVal NVARCHAR(32), @gTabNameVal sysname,    @storageTypeVal INTEGER, @geometryTypeVal INTEGER,    @CoordDimensionVal INTEGER, @sridVal INTEGER AS    SET NOCOUNT ON    BEGIN    BEGIN TRAN geocol_insert    INSERT INTO FORDATA_{1}.dbo.SDE_geometry_columns (f_table_catalog,f_table_schema,f_table_name, f_geometry_column,     g_table_catalog,g_table_schema,g_table_name,storage_type, geometry_type,    coord_dimension, srid) VALUES ( @fTabCatVal, @fTabSchVal,    @fTabNameVal, @fGeoColVal, @gTabCatVal, @gTabSchVal, @gTabNameVal,    @storageTypeVal, @geometryTypeVal, @CoordDimensionVal, @sridVal)    COMMIT TRAN geocol_insert    END
GO
/****** Object:  StoredProcedure [dbo].[SDE_geocol_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_geocol_def_delete]                 @fTableCatalogVal NVARCHAR(32), @fTableSchemaVal NVARCHAR(32),                @fTableNameVal sysname, @fGeometryColumnVal NVARCHAR(32) AS                 SET NOCOUNT ON                BEGIN                BEGIN TRAN geocol_delete                DELETE FROM FORDATA_{1}.dbo.SDE_geometry_columns WHERE f_table_catalog = @fTableCatalogVal AND                 f_table_schema = @fTableSchemaVal AND                 f_table_name = @fTableNameVal AND                 f_geometry_column = @fGeometryColumnVal                COMMIT TRAN geocol_delete                END
GO
/****** Object:  StoredProcedure [dbo].[SDE_geocol_def_change_table_name]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_geocol_def_change_table_name]              @tabNameVal sysname, @layerIdVal INTEGER AS SET NOCOUNT ON             UPDATE FORDATA_{1}.dbo.SDE_geometry_columns SET f_table_name = @tabNameVal FROM FORDATA_{1}.dbo.SDE_geometry_columns INNER JOIN FORDATA_{1}.dbo.SDE_layers ON (            (FORDATA_{1}.dbo.SDE_geometry_columns.f_table_catalog = FORDATA_{1}.dbo.SDE_layers.database_name) AND             (FORDATA_{1}.dbo.SDE_geometry_columns.f_table_schema = FORDATA_{1}.dbo.SDE_layers.owner) AND             (FORDATA_{1}.dbo.SDE_geometry_columns.f_table_name = FORDATA_{1}.dbo.SDE_layers.table_name) AND             (FORDATA_{1}.dbo.SDE_geometry_columns.f_geometry_column =  FORDATA_{1}.dbo.SDE_layers.spatial_column) )              WHERE layer_id= @layerIdVal
GO
/****** Object:  Trigger [RASTER_LAYER_5]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[RASTER_LAYER_5] 
on [dbo].[DEM_30M] for delete, update 
as  
begin  
declare @rowcount int 
select @rowcount = @@rowcount 
if @rowcount = 0 
return 
if update(Raster) 
begin 
declare @rascol_id  int, @obtained_raster_id int 
select @rascol_id = Raster from inserted 
if (@rascol_id IS NULL) 
begin 
update r set r.raster_flags = r.raster_id 
from FORDATA_{1}.DBO.SDE_ras_5 r , deleted d 
  where r.raster_id = d.Raster
 end 
else 
begin 
    DECLARE raster_id_cursor CURSOR FOR 
        SELECT raster_id FROM FORDATA_{1}.DBO.SDE_ras_5 
        WHERE raster_id = @rascol_id 
    open  raster_id_cursor 
    FETCH NEXT FROM raster_id_cursor INTO @obtained_raster_id 
     if (@@FETCH_STATUS <> 0) 
        RAISERROR ('Integrity error ...',16,-1)
     else if (select count(*) from DEM_30M where Raster = @rascol_id) > 1 
       RAISERROR ('Duplicate key in Raster column.',16,-1) 
     CLOSE raster_id_cursor 
     DEALLOCATE raster_id_cursor 
      return 
   end 
  return 
end 
if (select count(*) from inserted) > 0
return 
 update r set r.raster_flags = r.raster_id 
   from FORDATA_{1}.DBO.SDE_ras_5 r, deleted d 
    where r.raster_id = d.Raster
 end
GO
/****** Object:  Trigger [RASTER_LAYER_4]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[RASTER_LAYER_4] 
on [dbo].[HILLSHADE_30M] for delete, update 
as  
begin  
declare @rowcount int 
select @rowcount = @@rowcount 
if @rowcount = 0 
return 
if update(Raster) 
begin 
declare @rascol_id  int, @obtained_raster_id int 
select @rascol_id = Raster from inserted 
if (@rascol_id IS NULL) 
begin 
update r set r.raster_flags = r.raster_id 
from FORDATA_{1}.DBO.SDE_ras_4 r , deleted d 
  where r.raster_id = d.Raster
 end 
else 
begin 
    DECLARE raster_id_cursor CURSOR FOR 
        SELECT raster_id FROM FORDATA_{1}.DBO.SDE_ras_4 
        WHERE raster_id = @rascol_id 
    open  raster_id_cursor 
    FETCH NEXT FROM raster_id_cursor INTO @obtained_raster_id 
     if (@@FETCH_STATUS <> 0) 
        RAISERROR ('Integrity error ...',16,-1)
     else if (select count(*) from HILLSHADE_30M where Raster = @rascol_id) > 1 
       RAISERROR ('Duplicate key in Raster column.',16,-1) 
     CLOSE raster_id_cursor 
     DEALLOCATE raster_id_cursor 
      return 
   end 
  return 
end 
if (select count(*) from inserted) > 0
return 
 update r set r.raster_flags = r.raster_id 
   from FORDATA_{1}.DBO.SDE_ras_4 r, deleted d 
    where r.raster_id = d.Raster
 end
GO
/****** Object:  Trigger [INSERT_RASTER_LAYER_5]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[INSERT_RASTER_LAYER_5] 
on [dbo].[DEM_30M] for insert 
 as 
 DECLARE @rowc int 
 SELECT @rowc = @@rowcount 
if @@rowcount = 0 
return 
else 
begin 
DECLARE @rascol_id int, @obtained_raster_id int 
select @rascol_id = Raster from inserted 
if (@rascol_id IS NOT NULL) 
begin 
   DECLARE raster_id_cursor CURSOR FOR 
   SELECT raster_id FROM FORDATA_{1}.DBO.SDE_ras_5 
   WHERE raster_id = @rascol_id 
   open  raster_id_cursor 
   FETCH NEXT FROM raster_id_cursor INTO @obtained_raster_id 
 if (@@FETCH_STATUS <> 0) 
  RAISERROR ('Integrity error ...',16,-1) 
 else if (select count(*) from DEM_30M where Raster = @rascol_id) > 1 
  RAISERROR ('Duplicate key in Raster column.',16,-1)  
   CLOSE raster_id_cursor 
  DEALLOCATE raster_id_cursor 
 return 
end 
end
GO
/****** Object:  Trigger [INSERT_RASTER_LAYER_4]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TRIGGER [dbo].[INSERT_RASTER_LAYER_4] 
on [dbo].[HILLSHADE_30M] for insert 
 as 
 DECLARE @rowc int 
 SELECT @rowc = @@rowcount 
if @@rowcount = 0 
return 
else 
begin 
DECLARE @rascol_id int, @obtained_raster_id int 
select @rascol_id = Raster from inserted 
if (@rascol_id IS NOT NULL) 
begin 
   DECLARE raster_id_cursor CURSOR FOR 
   SELECT raster_id FROM FORDATA_{1}.DBO.SDE_ras_4 
   WHERE raster_id = @rascol_id 
   open  raster_id_cursor 
   FETCH NEXT FROM raster_id_cursor INTO @obtained_raster_id 
 if (@@FETCH_STATUS <> 0) 
  RAISERROR ('Integrity error ...',16,-1) 
 else if (select count(*) from HILLSHADE_30M where Raster = @rascol_id) > 1 
  RAISERROR ('Duplicate key in Raster column.',16,-1)  
   CLOSE raster_id_cursor 
  DEALLOCATE raster_id_cursor 
 return 
end 
end
GO
/****** Object:  StoredProcedure [dbo].[SDE_archives_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_archives_def_insert]
@archivingRegIdVal INTEGER, @historyRegIdVal INTEGER,
@fromDateVal NVARCHAR(32),
@toDateVal NVARCHAR(32),
@archiveDateVal BIGINT, @archiveFlagsVal BIGINT
AS SET NOCOUNT ON
BEGIN
INSERT INTO FORDATA_{1}.dbo.SDE_archives
  (archiving_regid,history_regid,from_date,to_date,archive_date,archive_flags) VALUES
  (@archivingRegIdVal,@historyRegIdVal,@fromDateVal,@toDateVal,@archiveDateVal,@archiveFlagsVal)
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_archives_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_archives_def_delete]
@archivingRegIdVal INTEGER AS SET NOCOUNT ON
BEGIN
DELETE FROM FORDATA_{1}.dbo.SDE_archives WHERE archiving_regid =  @archivingRegIdVal
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_col_registry_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_col_registry_def_update]        @dbNameVal NVARCHAR(32), @tabNameVal sysname, @ownerVal NVARCHAR(32),       @colNameVal NVARCHAR(32), @sdeTypeVal INTEGER, @colSizeVal INTEGER,        @decDigitVal INTEGER, @descVal NVARCHAR(65), @objFlagsVal INTEGER,       @objIdVal INTEGER, @oldColNameVal NVARCHAR(32) AS SET NOCOUNT ON       UPDATE FORDATA_{1}.dbo.SDE_column_registry SET column_name = @colNameVal, sde_type = @sdeTypeVal,       column_size = @colSizeVal,        decimal_digits = @decDigitVal, description = @descVal,       object_flags = @objFlagsVal ,object_id = @objIdVal        WHERE database_name = @dbNameVal AND table_name = @tabNameVal AND              owner = @ownerVal AND column_name = @oldColNameVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_def_update]
@descVal NVARCHAR(65), @g1Val FLOAT, @g2Val FLOAT, @g3Val FLOAT,
@minxVal FLOAT, @minyVal FLOAT, @maxxVal FLOAT, @maxyVal FLOAT,
@minzVal FLOAT, @maxzVal FLOAT, @minmVal FLOAT, @maxmVal FLOAT,
@efVal INTEGER, @layerMaskVal INTEGER, @layerConVal  NVARCHAR(32),
@optArrSize INTEGER, @statDateVal INTEGER, @minIdVal INTEGER,
@layerIdVal INTEGER, @geometryTypeVal INTEGER, @secondarySridVal INTEGER AS
SET NOCOUNT ON
UPDATE FORDATA_{1}.dbo.SDE_layers
SET description = @descVal, gsize1 = @g1Val, gsize2 = @g2Val,
  gsize3 = @g3Val, minx = @minxVal, miny = @minyVal, maxx = @maxxVal,
  maxy = @maxyVal, minz = @minzVal, maxz = @maxzVal, minm = @minmVal,
  maxm = @maxmVal, eflags = @efVal, layer_mask = @layerMaskVal,
  layer_config = @layerConVal, optimal_array_size = @optArrSize,
  stats_date = @statDateVal, minimum_id = @minIdVal, secondary_srid = @secondarySridVal 
WHERE layer_id = @layerIdVal
UPDATE FORDATA_{1}.dbo.SDE_geometry_columns
SET geometry_type = @geometryTypeVal
FROM FORDATA_{1}.dbo.SDE_layers l
WHERE l.layer_id = @layerIdVal AND l.database_name = f_table_catalog
  AND l.owner = f_table_schema AND l.table_name = f_table_name AND
  l.spatial_column = f_geometry_column
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_def_mask_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_def_mask_update]              @maskVal INTEGER, @layeridVal INTEGER AS              SET NOCOUNT ON              BEGIN             BEGIN TRAN layer_mask_update             UPDATE FORDATA_{1}.dbo.SDE_layers              SET layer_mask = @maskVal              WHERE layer_id = @layeridVal             COMMIT TRAN layer_mask_update             END
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_def_insert]
@layerIdVal INTEGER, @descVal NVARCHAR(65),@dbNameVal NVARCHAR(32),
@tabNameVal sysname, @ownerVal NVARCHAR(32), @spColVal NVARCHAR(32),
@eflagsVal INTEGER, @layerMaskVal INTEGER, @gsize1Val FLOAT, @gsize2Val FLOAT,
@gsize3Val FLOAT,@minxVal FLOAT,@minyVal FLOAT, @maxxVal FLOAT, @maxyVal FLOAT,
@minzVal FLOAT, @maxzVal FLOAT,@minmVal FLOAT, @maxmVal FLOAT, @cdateVal INTEGER,
@layerConfigVal NVARCHAR(32),@optArraySizeVal INTEGER, @statsDateVal INTEGER,
@minIdVal INTEGER, @sridVal INTEGER, @baseId INTEGER, @secondarySridVal INTEGER AS
SET NOCOUNT ON
BEGIN
BEGIN TRAN layer_insert
INSERT INTO FORDATA_{1}.dbo.SDE_layers (layer_id,description,database_name,table_name,owner,
spatial_column,eflags,layer_mask,gsize1,gsize2,gsize3,minx,miny,maxx,maxy,
minz,maxz,minm, maxm,cdate,layer_config,optimal_array_size,stats_date,
minimum_id,srid,base_layer_id,secondary_srid) VALUES (@layerIdVal, @descVal,
@dbNameVal, @tabNameVal,
@ownerVal, @spColVal,@eflagsVal, @layerMaskVal, @gsize1Val, @gsize2Val, @gsize3Val,
@minxVal, @minyVal, @maxxVal, @maxyVal,@minzVal, @maxzVal, @minmVal, @maxmVal,
@cdateVal,@layerConfigVal, @optArraySizeVal, @statsDateVal, @minIdVal, @sridVal,
@baseId, @secondarySridVal)
COMMIT TRAN layer_insert
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_def_envelope_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_def_envelope_update]              @minxVal FLOAT, @minyVal FLOAT, @maxxVal FLOAT,              @maxyVal FLOAT, @minzVal FLOAT, @maxzVal FLOAT,              @minmVal FLOAT, @maxmVal FLOAT, @layeridVal INTEGER AS              SET NOCOUNT ON              BEGIN             BEGIN TRAN layer_env_update             UPDATE FORDATA_{1}.dbo.SDE_layers              SET minx = @minxVal,              miny = @minyVal,              maxx = @maxxVal,              maxy = @maxyVal,              minz = @minzVal,              maxz = @maxzVal,              minm = @minmVal,              maxm = @maxmVal              WHERE layer_id = @layeridVal             COMMIT TRAN layer_env_update             END
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_def_delete]               @layer_idVal INTEGER AS SET NOCOUNT ON             DELETE FROM FORDATA_{1}.dbo.SDE_layers WHERE layer_id = @layer_idVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_def_change_table_name]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_def_change_table_name]              @tabNameVal sysname, @layerIdVal INTEGER AS SET NOCOUNT ON             UPDATE FORDATA_{1}.dbo.SDE_layers SET              table_name = @tabNameVal  WHERE layer_id = @layerIdVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_check_lock_conflicts]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_check_lock_conflicts]
@sdeIdVal INTEGER,
@layerIdVal INTEGER,
@autoLockVal VARCHAR(1),
@lockTypeVal VARCHAR(1),
@minxVal BIGINT,
@minyVal BIGINT,
@maxxVal BIGINT,
@maxyVal BIGINT,
@lock_conflict INTEGER OUTPUT AS SET NOCOUNT ON
BEGIN
  DECLARE locks_cursor CURSOR LOCAL FAST_FORWARD FOR
    SELECT sde_id
    FROM   FORDATA_{1}.dbo.SDE_layer_locks WITH (TABLOCKX,HOLDLOCK)
    WHERE  layer_id = @layerIdVal AND
           (sde_id <> @sdeIdVal OR
           autolock = @autoLockVal) AND
           (lock_type = 'E' /* E: Exclusive lock */ OR
            @lockTypeVal = 'E') AND
           ((maxx >= @minxVal AND maxy >= @minyVal AND
             @maxxVal >= minx AND @maxyVal >= miny) OR
             (minx IS NULL OR @minxVal IS NULL))
  /* Find any conflicting locks.  The query we use is sensitive about
     whether we are trying to place an exclusive lock (in which case we
     have to consider all locks as possibly conflicting), or a shared lock
     (in which case we only have to worry about conflicting with exclusive
     locks).  In either case, the query will include a range expression so
     composed that a lock with NULL envelope variables will always match
     any other lock.  This is because a NULL envelope indicates a layer-
     wide lock.  With all of the about constraints in place, if any rows
     are returned, we probably have a conflict.  The last thing we have to
     check is if the connection owning the lock has somehow died without
     cleaning up. */
  OPEN locks_cursor
  DECLARE @id INTEGER
  DECLARE @loop_done INTEGER
  SET @lock_conflict = 0
  SET @loop_done = 0
  DECLARE @f_sde_id INTEGER
  WHILE @loop_done = 0
  BEGIN 
    FETCH NEXT FROM locks_cursor INTO @f_sde_id
    IF @@FETCH_STATUS = 0
    BEGIN
      /* We found a matching layer lock.  See if the owning connection
         id is still out there.  If not, then this lock is invalid. */

      SELECT @id = SO.object_id
        FROM tempdb.sys.objects SO INNER JOIN 
            FORDATA_{1}.dbo.SDE_process_information PR ON object_id (PR.table_name) = SO.object_id
        WHERE PR.sde_id = @f_sde_id

      IF @@ROWCOUNT > 0
      BEGIN
          /* we have a lock conflict! */
          SET @lock_conflict = 1
          SET @loop_done = 1
      END
      ELSE
      BEGIN
          /* defunct connection found, clean it up */
         EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @f_sde_id
       END
     END
     ELSE
       SET @loop_done = 1
  END /* while */
  CLOSE locks_cursor
  DEALLOCATE locks_cursor
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_current_version_writable]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_current_version_writable] @current_state BIGINT OUTPUT AS 
SET NOCOUNT ON BEGIN
--This is a private support procedure for SDE versioned views.
DECLARE @context_info VARCHAR(128)
SELECT @context_info = CAST (context_info AS VARCHAR(128))
FROM master.dbo.sysprocesses
WHERE spid = @@SPID AND CAST (context_info AS VARCHAR(128)) like 'SDE%'
DECLARE @protected CHAR (1)
DECLARE @delimiter INTEGER
IF @context_info IS NULL
  SET @delimiter = 0
ELSE
BEGIN
  SET @delimiter = charindex (',', @context_info)
  IF @delimiter != 0 -- move past the SDE token
    SET @delimiter = charindex (',', @context_info, @delimiter + 1)
END
IF @delimiter = 0
BEGIN
  -- No context info set, so we're working off the default version.
  DECLARE @status INTEGER
  SELECT @current_state = v.state_id, @status = v.status
  FROM   FORDATA_{1}.dbo.SDE_versions v
  WHERE  v.name = 'DEFAULT' AND v.owner = 'dbo'
  SET @protected = FORDATA_{1}.dbo.SDE_get_version_access (@status, 'dbo')
END
ELSE
BEGIN
  SET @protected = substring (@context_info, @delimiter + 1, 1)
  DECLARE @sde_delimiter INTEGER
  SET @sde_delimiter = charindex (',', @context_info)
  SET @current_state = CAST (substring (@context_info, @sde_delimiter + 1,
      @delimiter - @sde_delimiter - 1) AS BIGINT)
END
DECLARE @error_string NVARCHAR(256)
IF @protected = '1'
BEGIN
    SET @error_string = 'Current version is protected, and you ' +
                        'are not the owner.'
    RAISERROR (@error_string,16,-1)
    RETURN -1
END
-- Make sure that the state exists, and that the current user can write 
-- to it.
DECLARE @owner NVARCHAR (128)
DECLARE @closing_time DATETIME
SELECT @owner = owner, @closing_time = closing_time
FROM FORDATA_{1}.dbo.SDE_states
WHERE state_id = @current_state
IF (@owner IS NULL)
BEGIN
  SET @error_string = 'State ' + cast (@current_state AS VARCHAR (20)) +
                      ' not found.'
  RAISERROR (@error_string,16,-1)
  RETURN -1
END
DECLARE @user NVARCHAR (128)
EXECUTE FORDATA_{1}.dbo.SDE_get_current_user_name @user OUTPUT 
IF @user != @owner
BEGIN
  DECLARE @is_dba INTEGER
  SET @is_dba = FORDATA_{1}.dbo.SDE_is_user_sde_dba ()
  IF @is_dba = 0
  BEGIN
    SET @error_string = 'Not owner of state ' +
                        CAST (@current_state AS VARCHAR (20)) + '.'
    RAISERROR (@error_string,16,-1)
    RETURN -1
  END
END
IF @closing_time IS NOT NULL 
BEGIN
  SET @error_string = 'State ' + CAST (@current_state AS VARCHAR (20)) +
                      ' is closed.'
  RAISERROR (@error_string,16,-1)
  RETURN -1
END
RETURN 0
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_column_registry_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_column_registry_def_update]        @dbNameVal NVARCHAR(32), @tabNameVal sysname, @ownerVal NVARCHAR(32),       @colNameVal NVARCHAR(32), @sdeTypeVal INTEGER, @colSizeVal INTEGER,        @decDigitVal INTEGER, @descVal NVARCHAR(65), @objFlagsVal INTEGER,       @objIdVal INTEGER AS SET NOCOUNT ON       UPDATE FORDATA_{1}.dbo.SDE_column_registry SET sde_type = @sdeTypeVal, column_size = @colSizeVal,        decimal_digits = @decDigitVal, description = @descVal,       object_flags = @objFlagsVal ,object_id = @objIdVal        WHERE database_name = @dbNameVal AND table_name = @tabNameVal AND              owner = @ownerVal AND column_name = @colNameVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_column_registry_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_column_registry_def_insert]        @dbNameVal NVARCHAR(32), @tabNameVal sysname, @ownerVal NVARCHAR(32),       @colNameVal NVARCHAR(32), @sdeTypeVal INTEGER, @colSizeVal INTEGER,        @decDigitVal INTEGER, @descVal NVARCHAR(65), @objFlagsVal INTEGER,       @objIdVal INTEGER AS SET NOCOUNT ON       INSERT INTO FORDATA_{1}.dbo.SDE_column_registry (database_name, table_name, owner, column_name, sde_type,        column_size, decimal_digits,description,object_flags, object_id )        VALUES ( @dbNameVal, @tabNameVal, @ownerVal, @colNameVal, @sdeTypeVal,        @colSizeVal ,@decDigitVal, @descVal, @objFlagsVal, @objIdVal)
GO
/****** Object:  StoredProcedure [dbo].[SDE_column_registry_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_column_registry_def_delete]                         @dbNameVal NVARCHAR(32), @tabNameVal sysname,                         @ownerVal NVARCHAR(32), @colNameVal NVARCHAR(32) AS                         SET NOCOUNT ON DELETE FROM FORDATA_{1}.dbo.SDE_column_registry WHERE                         database_name = @dbNameVal AND table_name = @tabNameVal AND                         owner = @ownerVal AND column_name = @colNameVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_lock_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_lock_def_insert]
@sdeIdVal INTEGER,
@layerIdVal INTEGER,
@autoLockVal VARCHAR(1),
@lockTypeVal VARCHAR(1),
@minxVal BIGINT,
@minyVal BIGINT,
@maxxVal BIGINT,
@maxyVal BIGINT AS SET NOCOUNT ON
DECLARE @lock_conflict INTEGER
/* If this is not an autolock, delete any existing regular lock on this
   layer owned by this user.
   The lock is to be removed even if we subsequently encounter a lock
   conflict (this behavior is unique to layer locks).*/
BEGIN TRAN layer_lock_tran
IF @autoLockVal <> 'Y'
  EXECUTE FORDATA_{1}.dbo.SDE_layer_lock_def_delete @sdeIdVal, @layerIdVal, @autoLockVal
/* check for conflicts */

  DECLARE locks_cursor CURSOR LOCAL FAST_FORWARD FOR
    SELECT sde_id
    FROM   FORDATA_{1}.dbo.SDE_layer_locks WITH (TABLOCKX,HOLDLOCK)
    WHERE  layer_id = @layerIdVal AND
           (sde_id <> @sdeIdVal OR
           autolock = @autoLockVal) AND
           (lock_type = 'E' /* E: Exclusive lock */ OR
            @lockTypeVal = 'E') AND
           ((maxx >= @minxVal AND maxy >= @minyVal AND
             @maxxVal >= minx AND @maxyVal >= miny) OR
             (minx IS NULL OR @minxVal IS NULL))
  /* Find any conflicting locks.  The query we use is sensitive about
     whether we are trying to place an exclusive lock (in which case we
     have to consider all locks as possibly conflicting), or a shared lock
     (in which case we only have to worry about conflicting with exclusive
     locks).  In either case, the query will include a range expression so
     composed that a lock with NULL envelope variables will always match
     any other lock.  This is because a NULL envelope indicates a layer-
     wide lock.  With all of the about constraints in place, if any rows
     are returned, we probably have a conflict.  The last thing we have to
     check is if the connection owning the lock has somehow died without
     cleaning up. */
  OPEN locks_cursor
  DECLARE @loop_done INTEGER
  DECLARE @id INTEGER
  SET @lock_conflict = 0
  SET @loop_done = 0
  DECLARE @f_sde_id INTEGER
  WHILE @loop_done = 0
  BEGIN 
    FETCH NEXT FROM locks_cursor INTO @f_sde_id
    IF @@FETCH_STATUS = 0
    BEGIN
      /* We found a matching layer lock.  See if the owning connection
         id is still out there.  If not, then this lock is invalid. */

      SELECT @id = SO.object_id
        FROM tempdb.sys.objects SO INNER JOIN 
            FORDATA_{1}.dbo.SDE_process_information PR ON object_id (PR.table_name) = SO.object_id
        WHERE PR.sde_id = @f_sde_id

      IF @@ROWCOUNT > 0
      BEGIN
        /* we have a lock conflict! */
        SET @lock_conflict = 1
        SET @loop_done = 1
      END
      ELSE
      BEGIN
        /* defunct connection found, clean it up */
        EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @f_sde_id
      END
     END
     ELSE
       SET @loop_done = 1
  END /* while */
  CLOSE locks_cursor
  DEALLOCATE locks_cursor

DECLARE @ret_val INTEGER
IF (@lock_conflict = 0)
BEGIN
  INSERT INTO FORDATA_{1}.dbo.SDE_layer_locks
         (sde_id,layer_id,autolock,lock_type,minx,miny,maxx,maxy)
  VALUES (@sdeIdVal,@layerIdVal,@autoLockVal,@lockTypeVal,@minxVal,
          @minyVal,@maxxVal,@maxyVal)
  SET @ret_val = 0 /* SE_SUCCESS */
  COMMIT TRAN layer_lock_tran
END
ELSE
BEGIN
  SET @ret_val = -49 /* SE_LOCK_CONFLICT */
  ROLLBACK TRAN layer_lock_tran
END
RETURN @ret_val
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_columns_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_columns_def_update]
@columnIdVal INTEGER, @indexIdVal INTEGER, @minimumIdVal INTEGER,
@configKeywordVal NVARCHAR(32), @xflagsVal INTEGER
AS SET NOCOUNT ON
BEGIN
-- Either we're updating all three columns, or just the index
IF @minimumIdVal IS NOT NULL
BEGIN
  UPDATE FORDATA_{1}.dbo.SDE_xml_columns
  SET index_id =  @indexIdVal,
  minimum_id =  @minimumIdVal,
  config_keyword =  @configKeywordVal,
  xflags =  @xflagsVal
  WHERE column_id =  @columnIdVal
END
ELSE
BEGIN
  UPDATE FORDATA_{1}.dbo.SDE_xml_columns
  SET index_id =  @indexIdVal
  WHERE column_id =  @columnIdVal
END
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_columns_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_columns_def_insert]
@regIdVal INTEGER, @colNameVal NVARCHAR(32),
@indexIdVal INTEGER, @minimumIdVal INTEGER,
@configKeywordVal NVARCHAR(32), @xflagsVal INTEGER
AS SET NOCOUNT ON
BEGIN
INSERT INTO FORDATA_{1}.dbo.SDE_xml_columns
  (registration_id, column_name, index_id, minimum_id, config_keyword, xflags) VALUES
  (@regIdVal, @colNameVal, @indexIdVal, @minimumIdVal, @configKeywordVal, @xflagsVal)
DECLARE @column_id INTEGER
SELECT @column_id = @@IDENTITY
RETURN @column_id
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_columns_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_columns_def_delete]
@columnIdVal INTEGER AS SET NOCOUNT ON
BEGIN
DELETE FROM FORDATA_{1}.dbo.SDE_xml_columns WHERE column_id =  @columnIdVal
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_table_check_lock_conflicts]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_table_check_lock_conflicts]
@sdeIdVal INTEGER,
@registrationIdVal INTEGER,
@lockTypeVal VARCHAR(1),
@lock_conflict INTEGER OUTPUT AS SET NOCOUNT ON
BEGIN
  DECLARE locks_cursor CURSOR LOCAL FAST_FORWARD FOR
    SELECT sde_id
    FROM   FORDATA_{1}.dbo.SDE_table_locks WITH (TABLOCKX,HOLDLOCK)
    WHERE  registration_id = @registrationIdVal AND
           (lock_type = 'E' /* E: Exclusive lock */ OR
           @lockTypeVal = 'E')
  /* Find any conflicting locks.  The query we use is sensitive about
     whether we are trying to place an exclusive lock (in which case we
     have to consider all locks as possibly conflicting), or a shared lock
     (in which case we only have to worry about conflicting with exclusive
     locks).  With all of the about constraints in place, if any rows
     are returned, we probably have a conflict.  The last thing we have to
     check is if the connection owning the lock has somehow died without
     cleaning up. */
  OPEN locks_cursor
  DECLARE @loop_done INTEGER
  DECLARE @id INTEGER
  SET @lock_conflict = 0
  SET @loop_done = 0
  DECLARE @f_sde_id INTEGER
  WHILE @loop_done = 0
  BEGIN 
    FETCH NEXT FROM locks_cursor
      INTO @f_sde_id
    IF @@FETCH_STATUS = 0
    BEGIN
      /* We found a matching table lock.  See if the owning connection
         id is still out there.  If not, then this lock is invalid. */

      SELECT @id = SO.object_id
        FROM tempdb.sys.objects SO INNER JOIN
            FORDATA_{1}.dbo.SDE_process_information        PR ON object_id (PR.table_name) = SO.object_id
        WHERE PR.sde_id = @f_sde_id

      IF @@ROWCOUNT > 0
      BEGIN
        /* we have a lock conflict! */
        SET @lock_conflict = 1
        SET @loop_done = 1
      END
      ELSE
      BEGIN
         /* defunct connection found, clean it up */
         EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @f_sde_id
      END
     END
     ELSE
       SET @loop_done = 1
  END /* while */
  CLOSE locks_cursor
  DEALLOCATE locks_cursor
END
GO
/****** Object:  View [dbo].[ST_GEOMETRY_COLUMNS]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [dbo].[ST_GEOMETRY_COLUMNS] (table_schema, table_name,       column_name, type_schema, type_name,  srs_id) AS        SELECT f_table_schema, f_table_name, f_geometry_column,'dbo',       CASE geometry_type        WHEN 0 THEN 'ST_GEOMETRY'        WHEN 1 THEN 'ST_POINT'        WHEN 2 THEN 'ST_CURVE'        WHEN 3 THEN 'ST_LINESTRING'        WHEN 4 THEN 'ST_SURFACE'        WHEN 5 THEN 'ST_POLYGON'        WHEN 6 THEN 'ST_COLLECTION'        WHEN 7 THEN 'ST_MULTIPOINT'        WHEN 8 THEN 'ST_MULTICURVE'        WHEN 9 THEN 'ST_MULTISTRING'        WHEN 10 THEN 'ST_MULTISURFACE'        WHEN 11 THEN 'ST_MULTIPOLYGON'        ELSE 'ST_GEOMETRY'        END,        srid FROM FORDATA_{1}.dbo.SDE_geometry_columns g
GO
/****** Object:  StoredProcedure [dbo].[set_current_version]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[set_current_version] 
@version_name NVARCHAR (97) AS SET NOCOUNT ON
BEGIN
-- This is a public support function for SDE versioned views. When working with
-- versioned views, call this procedure with the version name you wish the views to
-- reflect. Failure to call this procedure will cause versioned views to be based
-- on version 'sde.default'.

DECLARE @error_string NVARCHAR(256)
DECLARE @ret_code INTEGER
DECLARE @parsed_name NVARCHAR (64)
DECLARE @parsed_owner NVARCHAR (32)
-- Parse the version name.
EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_parse_version_name @version_name,
                    @parsed_name OUTPUT,  @parsed_owner OUTPUT
IF (@ret_code != 0)
  RETURN
-- Fetch the state id.
DECLARE @state_id BIGINT
DECLARE @status INTEGER
SELECT @state_id = v.state_id, @status = v.status
FROM   FORDATA_{1}.dbo.SDE_versions v
WHERE  v.name = @parsed_name AND
       v.owner = @parsed_owner;
IF @state_id IS NULL
BEGIN
  SET @error_string = 'Version ' + @version_name + ' not found.'
  RAISERROR (@error_string,16,-1)
  RETURN
END
-- Check the version status: if private, we must be owner to continue,
-- if protected, note for future use.
DECLARE @protected CHAR (1)
SET @protected = FORDATA_{1}.dbo.SDE_get_version_access (@status, @parsed_owner)
IF @protected = '2'
BEGIN
  DECLARE @login  NVARCHAR (128)
  SELECT @login = suser_sname()
  SET @error_string = @login + ' is not the owner of version ' + 
                      @version_name + '.'
  RAISERROR (@error_string,16,-1)
  RETURN
END
-- Finally, set the context info with the state id and protected info
DECLARE @char_context_info VARCHAR(35)
SET @char_context_info = 'SDE,' + CAST (@state_id AS VARCHAR(21)) + ',' 
    + @protected
DECLARE @varbin_context_info VARBINARY(128)
SET @varbin_context_info = CAST (@char_context_info AS VARBINARY(128) )
SET CONTEXT_INFO @varbin_context_info
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_index_tags_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_index_tags_def_update]
@indexIdVal INTEGER, @tagNameVal NVARCHAR(1024),
@tagAliasVal INTEGER, @descriptionVal NVARCHAR(64),
@isExcludedVal INTEGER AS
SET NOCOUNT ON
BEGIN
  UPDATE FORDATA_{1}.dbo.SDE_xml_index_tags SET tag_alias = @tagAliasVal,
    description = @descriptionVal, is_excluded = @isExcludedVal
    WHERE index_id = @indexIdVal AND tag_name = @tagNameVal
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_index_tags_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_index_tags_def_insert]
@index_id INTEGER, @tagNameVal NVARCHAR(1024),
@dataTypeVal INTEGER, @tagAliasVal INTEGER,
@descriptionVal NVARCHAR(64), @excluded  INTEGER
AS SET NOCOUNT ON
BEGIN
  INSERT INTO FORDATA_{1}.dbo.SDE_xml_index_tags
   (index_id, tag_name, data_type, tag_alias, description, is_excluded)   VALUES (@index_id, @tagNameVal, @dataTypeVal, @tagAliasVal,
           @descriptionVal, @excluded)
  DECLARE @tag_id INTEGER
  SELECT @tag_id = @@IDENTITY
  RETURN @tag_id
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_xml_index_tags_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_xml_index_tags_def_delete]
@indexIdVal INTEGER, @id1 INTEGER, @id2 INTEGER, @id3 INTEGER,
@id4 INTEGER, @id5 INTEGER, @id6 INTEGER, @id7 INTEGER, @id8 INTEGER AS
SET NOCOUNT ON
BEGIN
  DELETE FROM FORDATA_{1}.dbo.SDE_xml_index_tags WHERE index_id = @indexIdVal
  AND tag_id IN (@id1, @id2, @id3, @id4, @id5, @id6, @id7, @id8)
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_new_edit]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_new_edit]
@stateIdVal BIGINT, @ownerVal NVARCHAR(32),
@pStateIdVal BIGINT, @pLineageNameVal BIGINT OUTPUT,
@sdeIdVal INTEGER,
@crTimeVal DATETIME OUTPUT AS SET NOCOUNT ON
BEGIN
  DECLARE @new_lineage_name BIGINT
  DECLARE @ClosingTime DATETIME

  BEGIN TRAN state_new_edit
  --  Close parent state if it is open
  SELECT @ClosingTime = closing_time FROM FORDATA_{1}.dbo.SDE_states
     WHERE state_id = @pStateIdVal

  SET @crTimeVal = GETDATE()
  IF @ClosingTime  IS NULL
  BEGIN
     UPDATE FORDATA_{1}.dbo.SDE_states SET closing_time =  @crTimeVal 
          WHERE state_id = @pStateIdVal
  END

  SET @new_lineage_name = @pLineageNameVal
  BEGIN TRY
    INSERT INTO FORDATA_{1}.dbo.SDE_states (state_id,owner,
      creation_time, closing_time,parent_state_id,lineage_name) VALUES
      (@stateIdVal, @ownerVal, @crTimeVal, NULL, @pStateIdVal,
       @pLineageNameVal)
  END TRY
  BEGIN CATCH
    IF ERROR_NUMBER() = 2627 /* unique constraint violation */ 
    BEGIN
      INSERT INTO FORDATA_{1}.dbo.SDE_states (state_id,owner,creation_time, closing_time,
                                  parent_state_id,lineage_name) VALUES 
                (@stateIdVal, @ownerVal, @crTimeVal, NULL, @pStateIdVal, 
                 @stateIdVal)
      SET @new_lineage_name = @stateIdVal
    END
    ELSE
    BEGIN
      -- rethrow unexpected error
      DECLARE @ErrorMessage    NVARCHAR(4000),
        @ErrorNumber     INT,
        @ErrorSeverity   INT,
        @ErrorState      INT,
        @ErrorLine       INT,
        @ErrorProcedure  NVARCHAR(200);
      SELECT @ErrorNumber = ERROR_NUMBER(),
        @ErrorSeverity = ERROR_SEVERITY(),
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE(),
        @ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-');
      SELECT @ErrorMessage = 
        N'Error %d, Level %d, State %d, Procedure %s, Line %d, ' +
        'Message: '+ ERROR_MESSAGE();
      RAISERROR (@ErrorMessage, @ErrorSeverity, 1,
        @ErrorNumber, @ErrorSeverity, @ErrorState,
        @ErrorProcedure, @ErrorLine);
    END
  END CATCH
  -- If we created a new lineage, insert it into the STATE_LINEAGE table
  --  in normalized form. 
  IF @new_lineage_name <> @pLineageNameVal
  BEGIN
    INSERT INTO FORDATA_{1}.dbo.SDE_state_lineages (lineage_name, lineage_id)
         SELECT @new_lineage_name,l.lineage_id
         FROM FORDATA_{1}.dbo.SDE_state_lineages l 
         WHERE l.lineage_name = @pLineageNameVal AND
               l.lineage_id <= @pStateIdVal
    SET @pLineageNameVal = @new_lineage_name
  END

  -- We also insert a row for this state, as if it were in its own
  -- state lineage. 

  INSERT INTO FORDATA_{1}.dbo.SDE_state_lineages  (lineage_name, lineage_id)
      VALUES (@new_lineage_name,@stateIdVal)

  -- Place a lock entry in the SDE_state_locks table.  Doing this directly
  -- is both safe and necessary.  Safe, as this is a newly created state
  -- so there can not be a conflict; necessary as this function needs to
  -- be efficient and secure, this is the only way to avoid rechecking
  -- the current user's access rights.

  INSERT INTO FORDATA_{1}.dbo.SDE_state_locks(sde_id,state_id,autolock,lock_type)
     VALUES (@sdeIdVal, @stateIdVal, 'N', 'E')
  COMMIT TRAN state_new_edit

END
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_def_delete]
@id1 BIGINT, @id2 BIGINT, @id3 BIGINT, @id4 BIGINT, @id5 BIGINT,
@id6 BIGINT, @id7 BIGINT, @id8 BIGINT AS SET NOCOUNT ON
BEGIN
  DECLARE @ret_code INTEGER
  SET @ret_code = 0
  -- If we are deleting a single state, we add an additional check
  -- to make sure that this state has no child states.  This
  -- prevents some potential timing problems with compress.
  IF @id2 = -1
  BEGIN
    DECLARE @SE_STATE_HAS_CHILDREN INTEGER
    SET @SE_STATE_HAS_CHILDREN = 50175

    DECLARE @childCount INTEGER
    SELECT @childCount = COUNT(*) FROM FORDATA_{1}.dbo.SDE_states
      WHERE  parent_state_id = @id1
    IF @childCount <> 0
    BEGIN
      SET @ret_code = @SE_STATE_HAS_CHILDREN
      RETURN @ret_code
    END
  END

  DELETE FROM FORDATA_{1}.dbo.SDE_mvtables_modified WHERE state_id IN
    (@id1, @id2, @id3, @id4, @id5, @id6, @id7, @id8)

  -- Delete any lineages about to be orphaned
  DELETE FROM FORDATA_{1}.dbo.SDE_state_lineages WHERE lineage_name IN
    (SELECT lineage_name FROM FORDATA_{1}.dbo.SDE_states S1 WHERE state_id in
         (@id1, @id2, @id3, @id4, @id5, @id6, @id7, @id8)
     AND NOT EXISTS (SELECT * FROM FORDATA_{1}.dbo.SDE_states S2
     WHERE S1.lineage_name = ABS(S2.lineage_name) AND S2.state_id NOT IN
         (@id1, @id2, @id3, @id4, @id5, @id6, @id7, @id8)))

  -- Delete the states
  DELETE FROM FORDATA_{1}.dbo.SDE_states WHERE state_id IN
    (@id1, @id2, @id3, @id4, @id5, @id6, @id7, @id8)

  -- Delete any automatically placed exclusive state locks.
  DELETE FROM FORDATA_{1}.dbo.SDE_state_locks WHERE  state_id IN
    (@id1, @id2, @id3, @id4, @id5, @id6, @id7, @id8) AND  state_id <> 0 AND
    autolock = 'Y' AND lock_type = 'E'
  RETURN @ret_code
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_trim_pre_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_trim_pre_delete]
@highStateIdVal BIGINT, @lowStateIdVal BIGINT AS SET NOCOUNT ON
BEGIN
  IF @lowStateIdVal = 0
  BEGIN
    -- We need to delete any modified flags before changing the high
    -- state to be the base state, or the states<->mvtables_modified
    -- integrity constraint will be violated, aborting the following.
    -- UPDATE. Similarly, we must also remove old state_lineages entries.

    DELETE FROM FORDATA_{1}.dbo.SDE_mvtables_modified
    WHERE  state_id  = @highStateIdVal
    DELETE FROM FORDATA_{1}.dbo.SDE_state_lineages
    WHERE  lineage_id  = @highStateIdVal

    -- We need to insert a 0,0 entry in the state_lineages table
    -- if it doesn't exist.
    DECLARE @baseIdExists INTEGER
    SELECT @baseIdExists = count(*) FROM FORDATA_{1}.dbo.SDE_state_lineages
      WHERE lineage_name = 0 AND lineage_id = 0
    IF (@baseIdExists = 0)
    BEGIN
      INSERT INTO FORDATA_{1}.dbo.SDE_state_lineages (lineage_name,lineage_id) VALUES (0,0)
    END
    -- Make sure the base state is closed and proper.
    UPDATE FORDATA_{1}.dbo.SDE_states
      SET parent_state_id = 0,
          owner = 'dbo',
          closing_time = ISNULL (closing_time,GETDATE()),
          lineage_name = 0
      WHERE state_id = 0
    -- Make the lineage_name negative of any immediate child state
    -- of the state becoming the base state, so that when we update
    -- the parent_state_id to become the base_state_id, we don't
    -- violate the states_uk constraint on parent_state_id and
    -- lineage_name.
    UPDATE FORDATA_{1}.dbo.SDE_states
      SET    lineage_name = -lineage_name
      WHERE  parent_state_id = @highStateIdVal
    -- Update the parent_id of any immediate child state of the state
    -- becoming the base state to be the base state.
    UPDATE FORDATA_{1}.dbo.SDE_states
      SET    parent_state_id = 0
      WHERE  parent_state_id = @highStateIdVal
    -- Update any versions based on the state becoming the base state
    -- to point at the base state instead.
    UPDATE FORDATA_{1}.dbo.SDE_versions
      SET    state_id = 0
      WHERE  state_id = @highStateIdVal
    -- Remove the high_state now that it has been compressed.
    DELETE FROM FORDATA_{1}.dbo.SDE_states
    WHERE  state_id = @highStateIdVal
  END
  ELSE
  BEGIN
    -- Update the parent_id but also invert the lineage id to avoid
    -- violating states_uk.
    UPDATE FORDATA_{1}.dbo.SDE_states
    SET    parent_state_id = (SELECT parent_state_id
                              FROM  FORDATA_{1}.dbo.SDE_states
                              WHERE  state_id = @lowStateIdVal),
           lineage_name = -lineage_name
    WHERE  state_id = @highStateIdVal
  END
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_lock_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_lock_def_insert]
@sdeIdVal INTEGER,
@stateIdVal BIGINT,
@autoLockVal VARCHAR(1),
@lockTypeVal VARCHAR(1) AS SET NOCOUNT ON
DECLARE @isConflictVal INTEGER
DECLARE @ret_val INTEGER
BEGIN TRAN state_lock_tran

/* Marks don't conflict and it doesn't hurt if they are duplicates, */
/* so skip all that for them */
IF @lockTypeVal <> 'M' 
BEGIN
/* Delete any existing lock on this state owned by this user. */
/* This gets it out of the way during conflict checking (it will be */
/* restored via rollback if a conflict is detected).*/
  EXECUTE FORDATA_{1}.dbo.SDE_state_lock_def_delete @sdeIdVal, @stateIdVal, @autoLockVal,0

/* check for conflicts */
  EXECUTE FORDATA_{1}.dbo.SDE_state_check_lock_conflicts @sdeIdVal,@stateIdVal,@autoLockVal,@lockTypeVal,@isConflictVal OUTPUT
END
ELSE
BEGIN
  SET @isConflictVal = 0
END

IF (@isConflictVal = 0)
BEGIN
  INSERT INTO FORDATA_{1}.dbo.SDE_state_locks
         (sde_id,state_id,autolock,lock_type)
  VALUES (@sdeIdVal,@stateIdVal,@autoLockVal,@lockTypeVal)
  SET @ret_val = 0 /* SE_SUCCESS */ 
  COMMIT TRAN state_lock_tran
END
ELSE
BEGIN
  SET @ret_val = -49 /* SE_LOCK_CONFLICT */
  ROLLBACK TRAN state_lock_tran
END
RETURN @ret_val
GO
/****** Object:  StoredProcedure [dbo].[SDE_table_lock_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_table_lock_def_insert]
@sdeIdVal INTEGER,
@registrationIdVal INTEGER,
@lockTypeVal VARCHAR(1) AS SET NOCOUNT ON
DECLARE @isConflictVal INTEGER
DECLARE @ret_val INTEGER
BEGIN TRAN table_lock_tran

/* Delete any existing lock on this table owned by this user.*/
/* This gets it out of the way during conflict checking (it will be*/
/* restored via rollback if a conflict is detected).*/
EXECUTE FORDATA_{1}.dbo.SDE_table_lock_def_delete @sdeIdVal, @registrationIdVal

/* check for conflicts */
EXECUTE FORDATA_{1}.dbo.SDE_table_check_lock_conflicts @sdeIdVal,@registrationIdVal,@lockTypeVal,@isConflictVal OUTPUT
IF (@isConflictVal = 0)
BEGIN
  INSERT INTO FORDATA_{1}.dbo.SDE_table_locks
         (sde_id,registration_id,lock_type)
  VALUES (@sdeIdVal,@registrationIdVal,@lockTypeVal)
  SET @ret_val = 0 /* SE_SUCCESS */ 
  COMMIT TRAN table_lock_tran
END
ELSE
BEGIN
  SET @ret_val = -49 /* SE_LOCK_CONFLICT */
  ROLLBACK TRAN table_lock_tran
END
RETURN @ret_val
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_lock_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_lock_def_update]
@sdeIdVal INTEGER,
@layerIdVal INTEGER,
@autoLockVal VARCHAR(1),
@lockTypeVal VARCHAR(1),
@minxVal BIGINT,
@minyVal BIGINT,
@maxxVal BIGINT,
@maxyVal BIGINT AS SET NOCOUNT ON
DECLARE @isConflictVal INTEGER
DECLARE @ret_val INTEGER
BEGIN TRAN layer_lock_tran
/* Delete the lock we are to update.  If it doesn't exist, we will
   report an error.  If it does exist, this will
   get it out of the way so we can test for conflicts.*/
  EXECUTE @ret_val = FORDATA_{1}.dbo.SDE_layer_lock_def_delete @sdeIdVal, @layerIdVal, @autoLockVal
  IF @ret_val <> 0
    RETURN @ret_val
/* check for conflicts */
EXECUTE FORDATA_{1}.dbo.SDE_layer_check_lock_conflicts @sdeIdVal,@layerIdVal,@autoLockVal,@lockTypeVal,@minxVal,
        @minyVal,@maxxVal,@maxyVal, @isConflictVal OUTPUT
IF (@isConflictVal = 0)
BEGIN
  INSERT INTO FORDATA_{1}.dbo.SDE_layer_locks
         (sde_id,layer_id,autolock,lock_type,minx,miny,maxx,maxy)
  VALUES (@sdeIdVal,@layerIdVal,@autoLockVal,@lockTypeVal,@minxVal,
          @minyVal,@maxxVal,@maxyVal)
  SET @ret_val = 0 /* SE_SUCCESS */
  COMMIT TRAN layer_lock_tran
END
ELSE
BEGIN
  SET @ret_val = -49 /* SE_LOCK_CONFLICT */
  ROLLBACK TRAN layer_lock_tran
END
RETURN @ret_val
GO
/****** Object:  StoredProcedure [dbo].[SDE_object_lock_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_object_lock_def_insert]
@sdeIdVal INTEGER,
@objectIdVal INTEGER,
@objectTypeVal INTEGER,
@applicationIdVal INTEGER,
@autoLockVal VARCHAR(1),
@lockTypeVal VARCHAR(1) AS SET NOCOUNT ON
DECLARE @isConflictVal INTEGER
DECLARE @ret_val INTEGER
BEGIN TRAN object_lock_tran

/* Delete any existing lock on this object owned by this user. */
/* This gets it out of the way during conflict checking (it will be */
/* restored via rollback if a conflict is detected).*/
EXECUTE FORDATA_{1}.dbo.SDE_object_lock_def_delete @sdeIdVal, @objectIdVal, @objectTypeVal,
  @applicationIdVal, @autoLockVal

/* check for conflicts */
EXECUTE FORDATA_{1}.dbo.SDE_object_check_lock_conflicts @sdeIdVal,@objectIdVal,@objectTypeVal,
  @applicationIdVal,@autoLockVal,@lockTypeVal,@isConflictVal OUTPUT
IF (@isConflictVal = 0)
BEGIN
  INSERT INTO FORDATA_{1}.dbo.SDE_object_locks
    (sde_id,object_id,object_type,application_id,autolock,lock_type)
  VALUES (@sdeIdVal,@objectIdVal,@objectTypeVal,@applicationIdVal,
    @autoLockVal,@lockTypeVal)
  SET @ret_val = 0 /* SE_SUCCESS */ 
  COMMIT TRAN object_lock_tran
END
ELSE
BEGIN
  SET @ret_val = -49 /* SE_LOCK_CONFLICT */
  ROLLBACK TRAN object_lock_tran
END
RETURN @ret_val
GO
/****** Object:  StoredProcedure [dbo].[SDE_mvmodified_table_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_mvmodified_table_insert]       @registration_idVal INTEGER, @state_idVal BIGINT AS      SET NOCOUNT ON      BEGIN      BEGIN TRAN mvmodified_insert      INSERT INTO FORDATA_{1}.dbo.SDE_mvtables_modified (registration_id, state_id)       VALUES ( @registration_idVal, @state_idVal )      COMMIT TRAN mvmodified_insert      END
GO
/****** Object:  StoredProcedure [dbo].[SDE_mvmodified_table_del_base_save]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_mvmodified_table_del_base_save]       @high_state_idVal BIGINT, @lineage_nameVal BIGINT, @id1 INTEGER,      @id2 INTEGER, @id3 INTEGER, @id4 INTEGER, @id5 INTEGER,      @id6 INTEGER, @id7 INTEGER, @id8 INTEGER AS      SET NOCOUNT ON      BEGIN      DELETE FROM FORDATA_{1}.dbo.SDE_mvtables_modified WHERE registration_id IN         (@id1, @id2, @id3, @id4, @id5, @id6, @id7, @id8)        AND state_id IN (SELECT state_id FROM FORDATA_{1}.dbo.SDE_states WHERE state_id > 0 AND        state_id <= @high_state_idVal AND lineage_name = @lineage_nameVal)      END
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_stats_def_update]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_stats_def_update]
@layerIdVal INTEGER, @versionIdVal INTEGER,
@minxVal FLOAT,@minyVal FLOAT, @maxxVal FLOAT, @maxyVal FLOAT,
@minzVal FLOAT, @maxzVal FLOAT,@minmVal FLOAT, @maxmVal FLOAT,
@totalFeaturesVal INTEGER, @totalPointsVal INTEGER AS
SET NOCOUNT ON
BEGIN
BEGIN TRAN layer_stats_update
IF @versionIdVal IS NULL
BEGIN
  UPDATE FORDATA_{1}.dbo.SDE_layer_stats  SET minx = @minxVal, miny = @minyVal, maxx = @maxxVal, maxy = @maxyVal,
      minz = @minzVal, maxz = @maxzVal, minm = @minmVal, maxm = @maxmVal,
      total_features = @totalFeaturesVal, total_points = @totalPointsVal,
      last_analyzed = GETDATE()
  WHERE layer_id = @layerIdVal AND version_id IS NULL
END
ELSE
BEGIN
  UPDATE FORDATA_{1}.dbo.SDE_layer_stats  SET minx = @minxVal, miny = @minyVal, maxx = @maxxVal, maxy = @maxyVal,
      minz = @minzVal, maxz = @maxzVal, minm = @minmVal, maxm = @maxmVal,
      total_features = @totalFeaturesVal, total_points = @totalPointsVal,
      last_analyzed = GETDATE()
  WHERE layer_id = @layerIdVal AND version_id = @versionIdVal
END
COMMIT TRAN layer_stats_update
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_stats_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_stats_def_insert]
@layerIdVal INTEGER, @versionIdVal INTEGER,
@minxVal FLOAT,@minyVal FLOAT, @maxxVal FLOAT, @maxyVal FLOAT,
@minzVal FLOAT, @maxzVal FLOAT,@minmVal FLOAT, @maxmVal FLOAT,
@totalFeaturesVal INTEGER, @totalPointsVal INTEGER AS
SET NOCOUNT ON
BEGIN
BEGIN TRAN layer_stats_insert
INSERT INTO FORDATA_{1}.dbo.SDE_layer_stats (layer_id,version_id, 
  minx, miny, maxx, maxy, minz, maxz, minm, maxm, 
  total_features, total_points, last_analyzed)
 VALUES (@layerIdVal, @versionIdVal, @minxVal, @minyVal, @maxxVal, @maxyVal,
  @minzVal, @maxzVal, @minmVal, @maxmVal, @totalFeaturesVal, @totalPointsVal,
  GETDATE())
COMMIT TRAN layer_stats_insert
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_layer_stats_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_layer_stats_def_delete]
@layerIdVal INTEGER, @versionIdVal INTEGER AS
SET NOCOUNT ON
BEGIN
BEGIN TRAN layer_stats_delete
IF @versionIdVal <= 0
BEGIN
  DELETE FROM FORDATA_{1}.dbo.SDE_layer_stats  WHERE layer_id = @layerIdVal AND version_id IS NULL
END
ELSE
BEGIN
  DELETE FROM FORDATA_{1}.dbo.SDE_layer_stats  WHERE layer_id = @layerIdVal AND version_id = @versionIdVal
END
COMMIT TRAN layer_stats_delete
END
GO
/****** Object:  StoredProcedure [dbo].[SDE_registry_def_delete]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_registry_def_delete]        @regIdVal INTEGER AS SET NOCOUNT ON       DELETE FROM FORDATA_{1}.dbo.SDE_mvtables_modified WHERE registration_id = @regIdVal 
       DELETE FROM FORDATA_{1}.dbo.SDE_table_registry WHERE registration_id = @regIdVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_registry_clear_modified]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_registry_clear_modified]                         @regIdVal INTEGER AS SET NOCOUNT ON DELETE FROM FORDATA_{1}.dbo.SDE_mvtables_modified WHERE                        registration_id = @regIdVal
GO
/****** Object:  StoredProcedure [dbo].[SDE_state_def_insert]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[SDE_state_def_insert]
@stateIdVal BIGINT, @ownerVal NVARCHAR(32), @pStateIdVal BIGINT,
@pLineageNameVal BIGINT OUTPUT, @sdeIdVal INTEGER,@OpenOrCloseVal INTEGER,
@crTimeVal DATETIME OUTPUT AS SET NOCOUNT ON
BEGIN
  DECLARE @new_lineage_name BIGINT
  DECLARE @clTimeVal DATETIME
  SET @new_lineage_name = @pLineageNameVal

  SET @crTimeVal = GETDATE()
  -- close state
  IF @OpenOrCloseVal = 2
  BEGIN
    SET @clTimeVal = @crTimeVal
  END
  ELSE
  BEGIN
    SET @clTimeVal = NULL
  END

  BEGIN TRAN state_insert
  BEGIN TRY
    INSERT INTO FORDATA_{1}.dbo.SDE_states (state_id,owner,
      creation_time, closing_time,parent_state_id,lineage_name) VALUES
      (@stateIdVal, @ownerVal, @crTimeVal, @clTimeVal, @pStateIdVal,
       @pLineageNameVal)
  END TRY
  BEGIN CATCH
    IF ERROR_NUMBER() = 2627 /* unique constraint violation */ 
    BEGIN
      INSERT INTO FORDATA_{1}.dbo.SDE_states (state_id,owner,creation_time, closing_time,
                                  parent_state_id,lineage_name) VALUES 
                (@stateIdVal, @ownerVal, @crTimeVal, @clTimeVal, @pStateIdVal, 
                 @stateIdVal)
      SET @new_lineage_name = @stateIdVal
    END
    ELSE
    BEGIN
      -- rethrow unexpected error
      DECLARE @ErrorMessage    NVARCHAR(4000),
        @ErrorNumber     INT,
        @ErrorSeverity   INT,
        @ErrorState      INT,
        @ErrorLine       INT,
        @ErrorProcedure  NVARCHAR(200);
      SELECT @ErrorNumber = ERROR_NUMBER(),
        @ErrorSeverity = ERROR_SEVERITY(),
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE(),
        @ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-');
      SELECT @ErrorMessage = 
        N'Error %d, Level %d, State %d, Procedure %s, Line %d, ' +
        'Message: '+ ERROR_MESSAGE();
      RAISERROR (@ErrorMessage, @ErrorSeverity, 1,
        @ErrorNumber, @ErrorSeverity, @ErrorState,
        @ErrorProcedure, @ErrorLine);
    END
  END CATCH
  -- If we created a new lineage, insert it into the STATE_LINEAGE table
  --  in normalized form. 
  IF @new_lineage_name <> @pLineageNameVal
  BEGIN
    INSERT INTO FORDATA_{1}.dbo.SDE_state_lineages (lineage_name, lineage_id)
         SELECT @new_lineage_name,l.lineage_id
         FROM FORDATA_{1}.dbo.SDE_state_lineages l 
         WHERE l.lineage_name = @pLineageNameVal AND
               l.lineage_id <= @pStateIdVal
    SET @pLineageNameVal = @new_lineage_name
  END

  -- We also insert a row for this state, as if it were in its own
  -- state lineage. 

  INSERT INTO FORDATA_{1}.dbo.SDE_state_lineages  (lineage_name, lineage_id)
      VALUES (@new_lineage_name,@stateIdVal)

  -- Place a mark on the new state so that it doesn't get cleaned up
  -- by compress.  Do it before the commit so it won't ever be both
  -- visible and unmarked at the same time.

  EXECUTE FORDATA_{1}.dbo.SDE_state_lock_def_insert @sdeIdVal, @stateIdVal, 'Y', 'M'

  COMMIT TRAN state_insert
END
GO
/****** Object:  StoredProcedure [dbo].[create_version]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[create_version] 
@parent_name NVARCHAR (97),
@name NVARCHAR (64) OUTPUT,
@name_rule INTEGER,
@access INTEGER,
@description NVARCHAR(64) AS SET NOCOUNT ON
BEGIN
  /* This is a public procedure to create an SDE version.
  The new version will be a child of the given parent version name.
  The new version may have a unique name generated, depending on the
  value of the name_rule parameter. Valid name rules are:
  1 - generate a new name if there's already a version with the given name.
    In this case, the new name will be returned in the @name parameter, 
    as long as the caller supplied the OUTPUT keyword with the parameter.
  2 - Only use the name supplied, return an error if it already exists.

  The access parameter specified the new version's access as follows:
  0 - private version.
  1 - public version.
  2 - protected version. */

  -- Setup possible return codes

  DECLARE @SE_NO_PERMISSIONS INTEGER
  SET @SE_NO_PERMISSIONS = 50025

  DECLARE @SE_LOCK_CONFLICT INTEGER
  SET @SE_LOCK_CONFLICT = 50049

  DECLARE @SE_INVALID_PARAM_VALUE INTEGER
  SET @SE_INVALID_PARAM_VALUE = 50066

  DECLARE @SE_VERSION_NOEXIST INTEGER
  SET @SE_VERSION_NOEXIST = 50126

  DECLARE @SE_INVALID_VERSION_NAME INTEGER
  SET @SE_INVALID_VERSION_NAME = 50171

  DECLARE @SE_STATE_NOEXIST INTEGER
  SET @SE_STATE_NOEXIST = 50172

  DECLARE @SE_INVALID_VERSION_ID INTEGER
  SET @SE_INVALID_VERSION_ID = 50298

  -- Check arguments.

  IF @parent_name IS NULL

  BEGIN
    RAISERROR ('Parent version can not be NULL.',16,-1)
    RETURN @SE_VERSION_NOEXIST
  END

  DECLARE @parsed_name NVARCHAR(64)
  DECLARE @parsed_owner NVARCHAR(32)
  DECLARE @current_user NVARCHAR(32)
  DECLARE @error_string NVARCHAR(256)
  DECLARE @node_name  NVARCHAR(256)
  DECLARE @ret_code INTEGER

  EXECUTE FORDATA_{1}.dbo.SDE_get_current_user_name @current_user OUTPUT 
  EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_parse_version_name @name,
                      @parsed_name OUTPUT, 
                      @parsed_owner OUTPUT
  IF (@ret_code != 0)
    RETURN @ret_code

  IF @parsed_owner <> @current_user
  BEGIN
    RAISERROR ('The new version must be in the current user''s schema.', 16,-1)
    RETURN @SE_INVALID_VERSION_NAME
  END

  IF @access IS NULL
  BEGIN
    RAISERROR ('NULL is not a valid access type code.',16,-1)
    RETURN @SE_INVALID_PARAM_VALUE
  END
  ELSE IF @access < 0 OR @access > 2
  BEGIN
    SET @error_string = cast (@access AS VARCHAR (10)) + 
                       ' is not a valid access type code.'
    RAISERROR (@error_string,16,-1)
    RETURN @SE_INVALID_PARAM_VALUE
  END

  IF @name_rule IS NULL
  BEGIN
    RAISERROR ('NULL is not a valid name rule.',16,-1)
    RETURN @SE_INVALID_PARAM_VALUE
  END
  ELSE IF @name_rule < 1 OR @name_rule > 2
  BEGIN
   SET @error_string = cast (@name_rule AS VARCHAR (10)) + 
                       ' is not a valid name rule.'
    RAISERROR (@error_string,16,-1)
    RETURN @SE_INVALID_PARAM_VALUE
  END

  -- Fetch the proposed parent version.

  DECLARE @parsed_parent_name NVARCHAR(64)
  DECLARE @parsed_parent_owner NVARCHAR(32)
  DECLARE @parent_version_id INTEGER
  DECLARE @parent_state_id BIGINT
  DECLARE @parent_status INTEGER

  EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_parse_version_name @parent_name,
                      @parsed_parent_name OUTPUT,
                      @parsed_parent_owner OUTPUT
  IF (@ret_code != 0)
    RETURN @ret_code

  SELECT @parent_version_id = version_id, @parent_state_id = state_id,
         @parent_status = status
  FROM   FORDATA_{1}.dbo.SDE_versions
  WHERE  name = @parsed_parent_name AND
         owner = @parsed_parent_owner

  IF @parent_version_id IS NULL
  BEGIN
    SET @error_string = 'Version ' + @parent_name + ' not found.'
    RAISERROR (@error_string,16,-1)
    RETURN @SE_VERSION_NOEXIST
  END

  -- Check permissions.  At least one of the following must be true for this
  -- operation:  (1) The parent version must be public or protected, or
  --             (2) The current user is the parent version's owner, or
  --             (3) The current user is the SDE DBA user.

  DECLARE @protected CHAR (1)

  SET @protected = FORDATA_{1}.dbo.SDE_get_version_access (@parent_status,
                    @parsed_parent_owner)
  IF @protected = '2'
  BEGIN
    SET @error_string = 'Insufficient access to version ' + @parent_name
    RAISERROR (@error_string,16,-1)
    RETURN @SE_NO_PERMISSIONS
  END

  -- Get an sde connection id for locking purposes

  DECLARE @connection_id INTEGER
  EXECUTE FORDATA_{1}.dbo.SDE_get_primary_oid 12, 1, @connection_id OUTPUT

  -- We also need to insert into the process info table, otherwise if
  -- another process detects a lock conflict, this lock will be dropped
  -- since it doesn't belong to a valid SDE connection in the
  -- process info table.

  DECLARE @conn_tab NVARCHAR(95)
  SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
    + N'_FORDATA_{1}' 
  DECLARE @sql AS NVARCHAR (256)
  SET @sql = N'CREATE TABLE ' + @conn_tab + N' (keycol INTEGER)'
  EXEC (@sql)
  SET @conn_tab = N'tempdb.' + USER_NAME() + N'.' + @conn_tab
  SET @node_name = HOST_NAME()
  EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_insert @connection_id, 0,'Y',
    'Win32',@node_name,'F',@conn_tab

  -- Set the context info to flag this connection as a valid SDE lock
  -- Note that it may already have been set by SDE_set_current_version,
  -- and we don't want to overwrite that information.

  DECLARE @count INTEGER
  SELECT @count = count(*) FROM master.dbo.sysprocesses
    WHERE spid = @@spid AND CAST(context_info AS VARCHAR(40)) LIKE 'SDE%'
  IF @count = 0
  BEGIN
    DECLARE @varbin_context_info VARBINARY(128)
    SET @varbin_context_info = CAST ('SDE' AS VARBINARY(128))
    SET CONTEXT_INFO @varbin_context_info
  END

  -- Lock the underlying state, to make sure it stays still.

  EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_state_lock_def_insert @connection_id,
                      @parent_state_id, 'Y', 'S'
  IF @ret_code = -49
    SET @ret_code = @SE_LOCK_CONFLICT
  IF @ret_code != 0
  BEGIN
    EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
    SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
      + N'_FORDATA_{1}' 
    SET @sql = N'DROP TABLE ' + @conn_tab
    EXEC (@sql)
    RETURN @ret_code
  END

  -- Now that we have a lock, we safely check to see if the parent
  -- version's state still exists.

  DECLARE @state_id BIGINT

  SELECT @state_id = state_id
  FROM   FORDATA_{1}.dbo.SDE_states
  WHERE  state_id = @parent_state_id

  IF @state_id IS NULL
  BEGIN
    EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
    SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
      + N'_FORDATA_{1}' 
    SET @sql = N'DROP TABLE ' + @conn_tab
    EXEC (@sql)
    SET @error_string = 'State ' + cast (@parent_state_id AS VARCHAR (20))
                        + ' from version ' + @parent_name + ' not found.'
    RAISERROR (@error_string,16,-1)
    RETURN @SE_STATE_NOEXIST
  END

  -- Get a version ID.

  DECLARE @version_id INTEGER
  EXECUTE FORDATA_{1}.dbo.SDE_get_primary_oid 9, 1, @version_id OUTPUT

  IF @version_id IS NULL
  BEGIN
    EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
    SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
      + N'_FORDATA_{1}' 
    SET @sql = N'DROP TABLE ' + @conn_tab
    EXEC (@sql)
    SET @error_string = 'Unable to generate a version ID for ' +  @name
    RAISERROR (@error_string,16,-1)
    RETURN @SE_INVALID_VERSION_ID
  END

  -- Insert the new version.

  DECLARE @current_date DATETIME
  SET @current_date = GETDATE ()

  EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_versions_def_insert @parsed_name OUTPUT,
       @current_user, @version_id, @access, @parent_state_id, @description,
       @parsed_parent_name, @parsed_parent_owner, @parent_version_id,
       @current_date, @name_rule

  -- Set the returned name, in case we changed it.
  SET @name = @parsed_name

  -- It's now safe to remove the state lock and pinfo entry.

  SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
    + N'_FORDATA_{1}' 
  SET @sql = N'DROP TABLE ' + @conn_tab
  EXEC (@sql)
  EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id

  RETURN @ret_code
END
GO
/****** Object:  StoredProcedure [dbo].[delete_version]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[delete_version]
@name NVARCHAR (97) AS SET NOCOUNT ON
BEGIN
  -- This is a public procedure to delete an SDE version.

  -- Setup possible return codes

  DECLARE @SE_NO_PERMISSIONS INTEGER
  SET @SE_NO_PERMISSIONS = 50025

  DECLARE @SE_VERSION_NOEXIST INTEGER
  SET @SE_VERSION_NOEXIST = 50126

  DECLARE @SE_VERSION_HAS_CHILDREN INTEGER
  SET @SE_VERSION_HAS_CHILDREN = 50175

  DECLARE @SE_LOCK_CONFLICT INTEGER
  SET @SE_LOCK_CONFLICT = 50049

  DECLARE @parsed_name NVARCHAR(64)
  DECLARE @parsed_owner NVARCHAR(32)
  DECLARE @error_string NVARCHAR(256)
  DECLARE @ret_code INTEGER

  -- Parse the version name.

  EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_parse_version_name @name,
          @parsed_name OUTPUT, @parsed_owner OUTPUT
  IF (@ret_code != 0)
    RETURN @ret_code

  -- Make sure this is not the default version.

  IF @parsed_owner = 'dbo' AND @parsed_name = 'DEFAULT'
  BEGIN
    RAISERROR ('The default version may not be deleted.',16,-1)
    RETURN @SE_NO_PERMISSIONS
  END

  -- If we are not the DBA, make sure that we are the owner.

  DECLARE @current_user NVARCHAR(32)
  DECLARE @is_dba INTEGER
  SET @is_dba = FORDATA_{1}.dbo.SDE_is_user_sde_dba ()
  EXECUTE FORDATA_{1}.dbo.SDE_get_current_user_name @current_user OUTPUT

  IF @is_dba = 0
  BEGIN
    IF @current_user != @parsed_owner
    BEGIN
      SET @error_string = @current_user + ' not owner of version ' +
                          @name + '.'
      RAISERROR (@error_string,16,-1)
      RETURN @SE_NO_PERMISSIONS
    END
  END

  -- Make sure that the version exists.

  DECLARE @version_id INTEGER

  SELECT @version_id = version_id
  FROM   FORDATA_{1}.dbo.SDE_versions
  WHERE  name = @parsed_name AND
         owner = @parsed_owner

  IF @version_id IS NULL
  BEGIN
    SET @error_string = 'Version ' + @name + ' not found.'
    RAISERROR (@error_string,16,-1)
    RETURN @SE_VERSION_NOEXIST
  END

  -- Make sure that this version has no children.

  DECLARE @parent_version_id INTEGER

  SET @parent_version_id = NULL

  SELECT @parent_version_id = version_id
  FROM   FORDATA_{1}.dbo.SDE_versions
  WHERE  parent_name = @parsed_name AND
         parent_owner = @parsed_owner

  IF @parent_version_id IS NOT NULL
  BEGIN
    SET @error_string = 'Version ' + @name +
                        ' can not be deleted, as it has children.'
    RAISERROR (@error_string,16,-1)
    RETURN @SE_VERSION_HAS_CHILDREN
  END

  -- Place an object lock on the version to be deleted to be sure 
  -- it isn't currently in use.

  DECLARE @connection_id INTEGER

  -- Get an sde connection id for locking purposes

  EXECUTE FORDATA_{1}.dbo.SDE_get_primary_oid 12, 1, @connection_id OUTPUT

  -- We also need to insert into the process info table, otherwise if
  -- another process detects a lock conflict, this lock will be dropped
  -- since it doesn't belong to a valid SDE connection in the
  -- process info table.

  DECLARE @conn_tab NVARCHAR(95)
  DECLARE @node_name NVARCHAR(256)
  SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
    + N'_FORDATA_{1}' 
  DECLARE @sql AS NVARCHAR (256)
  SET @sql = N'CREATE TABLE ' + @conn_tab + N' (keycol INTEGER)'
  EXEC (@sql)
  SET @conn_tab = N'tempdb.' + USER_NAME() + N'.' + @conn_tab
  SET @node_name = HOST_NAME()
  EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_insert @connection_id, 0,'Y',
    'Win32',@node_name,'F',@conn_tab

  -- Lock the underlying object, to make sure it stays still.

  EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_object_lock_def_insert @connection_id,
                      @version_id,1,999, 'Y', 'E'
  IF @ret_code = -49
    SET @ret_code = @SE_LOCK_CONFLICT
  IF @ret_code != 0
  BEGIN
    EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
    SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
      + N'_FORDATA_{1}' 
    SET @sql = N'DROP TABLE ' + @conn_tab
    EXEC (@sql)
    SET @error_string = 'Unable to delete version ' +  @name + 
           ' which may be currently referenced by other object'
    RAISERROR (@error_string,16,-1)
    RETURN @ret_code
  END

  -- Perform the delete.

  EXECUTE FORDATA_{1}.dbo.SDE_versions_def_delete @parsed_owner, @parsed_name

  -- Remove the lock.
  EXECUTE FORDATA_{1}.dbo.SDE_object_lock_def_delete            @connection_id,@version_id,1,999,'Y'

  -- It's now safe to remove pinfo entry.

  SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
    + N'_FORDATA_{1}' 
  SET @sql = N'DROP TABLE ' + @conn_tab
  EXEC (@sql)
  EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id

END
GO
/****** Object:  StoredProcedure [dbo].[edit_version]    Script Date: 03/19/2014 09:13:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [dbo].[edit_version] 
@name NVARCHAR (97),
@edit_action INTEGER AS SET NOCOUNT ON
BEGIN

  /* This is a public procedure to toggle an SDE version's editability.
  If edit_action is 1, the version will be made editable by creating
  a new state as the child of the version's current state. The version
  will then point to this new state. The version will also be made the
  current version for versioned views.
  If edit_action is 2, the version will no longer be editable. The state
  it is pointing to will be closed. */
  -- Setup possible return codes

  DECLARE @SE_NO_PERMISSIONS INTEGER
  SET @SE_NO_PERMISSIONS = 50025

  DECLARE @SE_LOCK_CONFLICT INTEGER
  SET @SE_LOCK_CONFLICT = 50049

  DECLARE @SE_INVALID_PARAM_VALUE INTEGER
  SET @SE_INVALID_PARAM_VALUE = 50066

  DECLARE @SE_VERSION_NOEXIST INTEGER
  SET @SE_VERSION_NOEXIST = 50126

  DECLARE @SE_STATE_NOEXIST INTEGER
  SET @SE_STATE_NOEXIST = 50172

  DECLARE @SE_VERSION_HAS_MOVED INTEGER
  SET @SE_VERSION_HAS_MOVED = 50174

  DECLARE @SE_PARENT_NOT_CLOSED INTEGER
  SET @SE_PARENT_NOT_CLOSED = 50176

  DECLARE @SE_TRANS_IN_PROGRESS INTEGER
  SET @SE_TRANS_IN_PROGRESS = 50068

  DECLARE @parsed_name NVARCHAR(64)
  DECLARE @parsed_owner NVARCHAR(32)
  DECLARE @node_name  NVARCHAR(256)
  DECLARE @error_string NVARCHAR(256)
  DECLARE @ret_code INTEGER

  DECLARE @sql AS NVARCHAR (256)
  -- Check arguments.

  IF @edit_action IS NULL
  BEGIN
    RAISERROR ('Edit action may not be NULL.',16,-1)
    RETURN @SE_INVALID_PARAM_VALUE
  END
  ELSE IF @edit_action < 1 OR @edit_action > 2
  BEGIN
    SET @error_string = cast (@edit_action AS VARCHAR (10)) + 
                       ' is not a valid edit action code.'
    RETURN @SE_INVALID_PARAM_VALUE
  END

  -- Parse the version name
  EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_parse_version_name @name,
          @parsed_name OUTPUT, @parsed_owner OUTPUT
  IF (@ret_code != 0)
    RETURN @ret_code

  -- Get the information we need from the version.

  DECLARE @version_id INTEGER
  DECLARE @state_id BIGINT
  DECLARE @status INTEGER

  SELECT @version_id = version_id, @state_id = state_id,
         @status = status
  FROM   FORDATA_{1}.dbo.SDE_versions
  WHERE  name = @parsed_name AND
         owner = @parsed_owner

  IF @version_id IS NULL
  BEGIN
    SET @error_string = 'Version ' + @name + ' not found.'
    RAISERROR (@error_string,16,-1)
    RETURN @SE_VERSION_NOEXIST
  END

  -- Check permissions.  At least one of the following must be true for this
  -- operation:  (1) The version must be public, or
  --             (2) The current user is the version's owner, or
  --             (3) The current user is the SDE DBA user.

  DECLARE @protected CHAR (1)

  SET @protected = FORDATA_{1}.dbo.SDE_get_version_access (@status, @parsed_owner)
  IF @protected = '1' OR @protected = '2'
  BEGIN
    SET @error_string = 'Insufficient access to version ' + @name
    RAISERROR (@error_string,16,-1)
    RETURN @SE_NO_PERMISSIONS
  END

  -- Get an sde connection id for locking purposes

  DECLARE @connection_id INTEGER
  IF @edit_action = 2
  BEGIN
    IF @@TRANCOUNT > 0
    BEGIN
      SET @error_string = 'Transaction count = '         + CAST(@@TRANCOUNT as VARCHAR(10)) + '. Cannot close state with '        + 'pending changes.'
      RAISERROR (@error_string,16,-1)
      RETURN @SE_TRANS_IN_PROGRESS
    END
    SELECT @connection_id = sde_id from FORDATA_{1}.dbo.SDE_process_information WHERE spid = @@spid
  END
  IF @edit_action = 1 OR @connection_id IS NULL
  BEGIN
    EXECUTE FORDATA_{1}.dbo.SDE_get_primary_oid 12, 1, @connection_id OUTPUT

  -- We also need to insert into the process info table, otherwise if
  -- another process detects a lock conflict, this lock will be dropped
  -- since it doesn't belong to a valid SDE connection in the
  -- process info table.

    DECLARE @conn_tab NVARCHAR(95)
    SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
      + N'_FORDATA_{1}' 
    SET @sql = N'CREATE TABLE ' + @conn_tab + N' (keycol INTEGER)'
    EXEC (@sql)
    SET @conn_tab = N'tempdb.' + USER_NAME() + N'.' + @conn_tab
    SET @node_name = HOST_NAME()
    EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_insert @connection_id, 0,
      'Y','Win32',@node_name,'F',@conn_tab

  END
  -- Set the context info to flag this connection as a valid SDE lock
  -- Note that it may already have been set by SDE_set_current_version,
  -- and we don't want to overwrite that information.

  DECLARE @count INTEGER
  SELECT @count = count(*) FROM master.dbo.sysprocesses
    WHERE spid = @@spid AND CAST(context_info AS VARCHAR(40)) LIKE 'SDE%'
  IF @count = 0
  BEGIN
    DECLARE @varbin_context_info VARBINARY(128)
    SET @varbin_context_info = CAST ('SDE' AS VARBINARY(128))
    SET CONTEXT_INFO @varbin_context_info
  END

  -- Lock the version's state if this is a open edit.

  IF @edit_action = 1
  BEGIN
    EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_state_lock_def_insert @connection_id,
                       @state_id, 'Y', 'S'

    IF @ret_code = -49
      SET @ret_code = @SE_LOCK_CONFLICT
    IF @ret_code != 0
    BEGIN
      SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
        + N'_FORDATA_{1}' 
      SET @sql = N'DROP TABLE ' + @conn_tab
      EXEC (@sql)
      EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
      RETURN @ret_code
    END
  END

  DECLARE @state_owner NVARCHAR(32)
  DECLARE @closing_time DATETIME
  DECLARE @parent_lineage_name BIGINT

  DECLARE @current_user NVARCHAR(32)
  EXECUTE FORDATA_{1}.dbo.SDE_get_current_user_name @current_user OUTPUT

  DECLARE @current_date DATETIME
  SET @current_date = GETDATE ()

  -- Perform version open or close for editing.

  IF @edit_action = 2
  BEGIN
    -- If we are done editing, close the state.
    -- Make sure that the state exists, and that the current user can 
    -- write to it.
    SELECT @state_owner = owner, @closing_time = closing_time
    FROM   FORDATA_{1}.dbo.SDE_states
    WHERE  state_id = @state_id
    IF @state_owner IS NULL
    BEGIN
      SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
        + N'_FORDATA_{1}' 
      SET @sql = N'DROP TABLE ' + @conn_tab
      EXEC (@sql)
      EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
      SET @error_string = 'State ' + cast (@state_id AS VARCHAR (20)) +
                          ' from version ' + @name + ' not found.'
      RAISERROR (@error_string,16,-1)
      RETURN @SE_STATE_NOEXIST
    END

    DECLARE @is_dba INTEGER
    SET @is_dba = FORDATA_{1}.dbo.SDE_is_user_sde_dba ()

    IF @is_dba = 0
    BEGIN
      IF @current_user != @state_owner
      BEGIN
        SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
          + N'_FORDATA_{1}' 
        SET @sql = N'DROP TABLE ' + @conn_tab
        EXEC (@sql)
        EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
        SET @error_string = 'Not owner of state ' +
                            cast (@state_id AS VARCHAR (20)) + '.'
        RAISERROR (@error_string,16,-1)
        RETURN @SE_NO_PERMISSIONS
      END
    END

    BEGIN TRAN edit_version
    UPDATE FORDATA_{1}.dbo.SDE_states
    SET    closing_time = @current_date
    WHERE  state_id = @state_id
    COMMIT TRAN edit_version

    -- The change is made, we can release our locks (incl. mark state locks).

    SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
      + N'_FORDATA_{1}' 
    SET @sql = N'DROP TABLE ' + @conn_tab
    EXEC (@sql)
    EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
  END
  ELSE
  BEGIN
    -- If we starting editing, we will create a child of the current state,
    -- and move this version on to it.

    -- Fetch the information from the version's current state that we need
    -- to create the child state.

    SELECT @state_owner = owner, @closing_time = closing_time,
           @parent_lineage_name = lineage_name
    FROM   FORDATA_{1}.dbo.SDE_states
    WHERE  state_id = @state_id

    IF @state_owner IS NULL
    BEGIN
      SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
        + N'_FORDATA_{1}' 
      SET @sql = N'DROP TABLE ' + @conn_tab
      EXEC (@sql)
      EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
      SET @error_string = 'State ' + cast (@state_id AS VARCHAR (20)) +
                          ' from version ' + @name + ' not found.'
      RAISERROR (@error_string,16,-1)
      RETURN @SE_STATE_NOEXIST
    END

    -- If the version's current state is open, raise an error

    IF @closing_time IS NULL
    BEGIN
      SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
        + N'_FORDATA_{1}' 
      SET @sql = N'DROP TABLE ' + @conn_tab
      EXEC (@sql)
      EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
      SET @error_string = 'State ' + cast (@state_id AS VARCHAR (20)) +
                          ' from version ' + @name + ' is not closed.'
      RAISERROR (@error_string,16,-1)
      RETURN @SE_PARENT_NOT_CLOSED
    END

    -- Get a state ID.

    DECLARE @new_state_id BIGINT
    EXECUTE FORDATA_{1}.dbo.SDE_get_primary_oid 8, 1, @new_state_id OUTPUT

    -- Create the new state.

    EXECUTE FORDATA_{1}.dbo.SDE_state_def_insert  @new_state_id, @current_user,
                       @state_id, @parent_lineage_name,
                      @connection_id, 1, @current_date

    -- Unlock the parent state -- we don't need it any longer.

    EXECUTE FORDATA_{1}.dbo.SDE_state_lock_def_delete @connection_id, @state_id, 'Y', 0
    -- Move the version to the new state.

    EXECUTE FORDATA_{1}.dbo.SDE_versions_def_change_state @new_state_id, @parsed_name,
            @parsed_owner, @state_id
    IF @@ROWCOUNT = 0
    BEGIN
      -- determine if the version has been deleted or if it has
      -- already been changed
      SET @version_id = NULL
      SELECT @version_id = version_id
      FROM   FORDATA_{1}.dbo.SDE_versions
      WHERE  name = @parsed_name AND
            owner = @parsed_owner

      IF @version_id IS NULL
      BEGIN
        SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
          + N'_FORDATA_{1}' 
        SET @sql = N'DROP TABLE ' + @conn_tab
        EXEC (@sql)
        EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
        SET @error_string = 'Version ' + @name + ' not found.'
        RAISERROR (@error_string,16,-1)
        RETURN @SE_VERSION_NOEXIST
      END
      ELSE
      BEGIN
        SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
          + N'_FORDATA_{1}' 
        SET @sql = N'DROP TABLE ' + @conn_tab
        EXEC (@sql)
        EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
        SET @error_string = 'Version ' + @name + ' is no longer state ' +
                            cast (@state_id AS VARCHAR (10)) + '.'
        RAISERROR (@error_string,16,-1)
        RETURN @SE_VERSION_HAS_MOVED
      END
    END

    -- Now lock the new state with a persistent lock
    EXECUTE @ret_code = FORDATA_{1}.dbo.SDE_state_lock_def_insert @connection_id,
                       @new_state_id, 'Y', 'E'

    IF @ret_code = -49
      SET @ret_code = @SE_LOCK_CONFLICT
    IF @ret_code != 0
    BEGIN
      SET @conn_tab = N'##SDE_' + CAST(@connection_id as NVARCHAR(10))
        + N'_FORDATA_{1}' 
      SET @sql = N'DROP TABLE ' + @conn_tab
      EXEC (@sql)
      EXECUTE FORDATA_{1}.dbo.SDE_pinfo_def_delete @connection_id
      RETURN @ret_code
    END
    -- Set the now editable version as the current version.

    EXECUTE FORDATA_{1}.dbo.set_current_version @name
  END
END
GO
/****** Object:  Check [spatial_ref_xyunits]    Script Date: 03/19/2014 09:13:50 ******/
ALTER TABLE [dbo].[SDE_spatial_references]  WITH NOCHECK ADD  CONSTRAINT [spatial_ref_xyunits] CHECK  (([xyunits]>=(1)))
GO
ALTER TABLE [dbo].[SDE_spatial_references] CHECK CONSTRAINT [spatial_ref_xyunits]
GO
/****** Object:  Check [spatial_ref_zunits]    Script Date: 03/19/2014 09:13:50 ******/
ALTER TABLE [dbo].[SDE_spatial_references]  WITH NOCHECK ADD  CONSTRAINT [spatial_ref_zunits] CHECK  (([zunits]>=(1)))
GO
ALTER TABLE [dbo].[SDE_spatial_references] CHECK CONSTRAINT [spatial_ref_zunits]
GO
/****** Object:  Check [g26_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[INDEX_A_10K]  WITH NOCHECK ADD  CONSTRAINT [g26_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[INDEX_A_10K] CHECK CONSTRAINT [g26_ck]
GO
/****** Object:  Check [g17_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_P_XIANG_10K]  WITH CHECK ADD  CONSTRAINT [g17_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_P_XIANG_10K] CHECK CONSTRAINT [g17_ck]
GO
/****** Object:  Check [g18_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_P_XIAN_10K]  WITH CHECK ADD  CONSTRAINT [g18_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_P_XIAN_10K] CHECK CONSTRAINT [g18_ck]
GO
/****** Object:  Check [g16_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_P_WATER_10K]  WITH CHECK ADD  CONSTRAINT [g16_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_P_WATER_10K] CHECK CONSTRAINT [g16_ck]
GO
/****** Object:  Check [g15_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_P_LINBAN_10K]  WITH CHECK ADD  CONSTRAINT [g15_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_P_LINBAN_10K] CHECK CONSTRAINT [g15_ck]
GO
/****** Object:  Check [g19_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_P_CUN_10K]  WITH CHECK ADD  CONSTRAINT [g19_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_P_CUN_10K] CHECK CONSTRAINT [g19_ck]
GO
/****** Object:  Check [g20_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_L_XIANG_10K]  WITH CHECK ADD  CONSTRAINT [g20_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_L_XIANG_10K] CHECK CONSTRAINT [g20_ck]
GO
/****** Object:  Check [g21_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_L_XIAN_10K]  WITH CHECK ADD  CONSTRAINT [g21_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_L_XIAN_10K] CHECK CONSTRAINT [g21_ck]
GO
/****** Object:  Check [g22_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_L_ROAD_10K]  WITH CHECK ADD  CONSTRAINT [g22_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_L_ROAD_10K] CHECK CONSTRAINT [g22_ck]
GO
/****** Object:  Check [g23_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_L_LINBAN_10K]  WITH CHECK ADD  CONSTRAINT [g23_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_L_LINBAN_10K] CHECK CONSTRAINT [g23_ck]
GO
/****** Object:  Check [g24_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_L_CUN_10K]  WITH CHECK ADD  CONSTRAINT [g24_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_L_CUN_10K] CHECK CONSTRAINT [g24_ck]
GO
/****** Object:  Check [g25_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[BASE_D_RESIDENT_10K]  WITH CHECK ADD  CONSTRAINT [g25_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[BASE_D_RESIDENT_10K] CHECK CONSTRAINT [g25_ck]
GO
/****** Object:  Check [g32_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[FOR_XIAOBAN_{2}]  WITH CHECK ADD  CONSTRAINT [g32_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[FOR_XIAOBAN_{2}] CHECK CONSTRAINT [g32_ck]
GO
/****** Object:  Check [g12_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[FOR_XIAOBAN_{3}]  WITH CHECK ADD  CONSTRAINT [g12_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[FOR_XIAOBAN_{3}] CHECK CONSTRAINT [g12_ck]
GO
/****** Object:  Check [g14_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[FOR_XBBH_{2}]  WITH CHECK ADD  CONSTRAINT [g14_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[FOR_XBBH_{2}] CHECK CONSTRAINT [g14_ck]
GO
/****** Object:  Check [g7_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_ZL_{2}]  WITH CHECK ADD  CONSTRAINT [g7_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_ZL_{2}] CHECK CONSTRAINT [g7_ck]
GO
/****** Object:  Check [g4_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_ZH_{2}]  WITH CHECK ADD  CONSTRAINT [g4_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_ZH_{2}] CHECK CONSTRAINT [g4_ck]
GO
/****** Object:  Check [g3_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_YGJC_{2}]  WITH CHECK ADD  CONSTRAINT [g3_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_YGJC_{2}] CHECK CONSTRAINT [g3_ck]
GO
/****** Object:  Check [g2_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_LYAJ_{2}]  WITH CHECK ADD  CONSTRAINT [g2_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_LYAJ_{2}] CHECK CONSTRAINT [g2_ck]
GO
/****** Object:  Check [g8_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_LDZZ_{2}]  WITH CHECK ADD  CONSTRAINT [g8_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_LDZZ_{2}] CHECK CONSTRAINT [g8_ck]
GO
/****** Object:  Check [g5_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_L_LDZZ_{2}]  WITH CHECK ADD  CONSTRAINT [g5_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_L_LDZZ_{2}] CHECK CONSTRAINT [g5_ck]
GO
/****** Object:  Check [g6_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_HZ_{2}]  WITH CHECK ADD  CONSTRAINT [g6_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_HZ_{2}] CHECK CONSTRAINT [g6_ck]
GO
/****** Object:  Check [g9_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_D_LDZZ_{2}]  WITH CHECK ADD  CONSTRAINT [g9_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_D_LDZZ_{2}] CHECK CONSTRAINT [g9_ck]
GO
/****** Object:  Check [g10_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[ZT_CF_{2}]  WITH CHECK ADD  CONSTRAINT [g10_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[ZT_CF_{2}] CHECK CONSTRAINT [g10_ck]
GO
/****** Object:  Check [g30_ck]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[HILLSHADE_30M]  WITH CHECK ADD  CONSTRAINT [g30_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[HILLSHADE_30M] CHECK CONSTRAINT [g30_ck]
GO
/****** Object:  Check [g1_ck]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[GDB_ITEMS]  WITH NOCHECK ADD  CONSTRAINT [g1_ck] CHECK  (([Shape].[STSrid]=(4326)))
GO
ALTER TABLE [dbo].[GDB_ITEMS] CHECK CONSTRAINT [g1_ck]
GO
/****** Object:  Check [g31_ck]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[DEM_30M]  WITH CHECK ADD  CONSTRAINT [g31_ck] CHECK  (([SHAPE].[STSrid]=(4610)))
GO
ALTER TABLE [dbo].[DEM_30M] CHECK CONSTRAINT [g31_ck]
GO
/****** Object:  ForeignKey [xml_columns_fk1]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[SDE_xml_columns]  WITH CHECK ADD  CONSTRAINT [xml_columns_fk1] FOREIGN KEY([registration_id])
REFERENCES [dbo].[SDE_table_registry] ([registration_id])
GO
ALTER TABLE [dbo].[SDE_xml_columns] CHECK CONSTRAINT [xml_columns_fk1]
GO
/****** Object:  ForeignKey [xml_columns_fk2]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[SDE_xml_columns]  WITH CHECK ADD  CONSTRAINT [xml_columns_fk2] FOREIGN KEY([index_id])
REFERENCES [dbo].[SDE_xml_indexes] ([index_id])
GO
ALTER TABLE [dbo].[SDE_xml_columns] CHECK CONSTRAINT [xml_columns_fk2]
GO
/****** Object:  ForeignKey [xml_indextags_fk1]    Script Date: 03/19/2014 09:13:54 ******/
ALTER TABLE [dbo].[SDE_xml_index_tags]  WITH CHECK ADD  CONSTRAINT [xml_indextags_fk1] FOREIGN KEY([index_id])
REFERENCES [dbo].[SDE_xml_indexes] ([index_id])
ON DELETE CASCADE
GO
ALTER TABLE [dbo].[SDE_xml_index_tags] CHECK CONSTRAINT [xml_indextags_fk1]
GO
/****** Object:  ForeignKey [layers_fk]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_layers]  WITH NOCHECK ADD  CONSTRAINT [layers_fk] FOREIGN KEY([srid])
REFERENCES [dbo].[SDE_spatial_references] ([srid])
GO
ALTER TABLE [dbo].[SDE_layers] CHECK CONSTRAINT [layers_fk]
GO
/****** Object:  ForeignKey [layers_sfk]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_layers]  WITH NOCHECK ADD  CONSTRAINT [layers_sfk] FOREIGN KEY([secondary_srid])
REFERENCES [dbo].[SDE_spatial_references] ([srid])
GO
ALTER TABLE [dbo].[SDE_layers] CHECK CONSTRAINT [layers_sfk]
GO
/****** Object:  ForeignKey [archives_fk1]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_archives]  WITH CHECK ADD  CONSTRAINT [archives_fk1] FOREIGN KEY([archiving_regid])
REFERENCES [dbo].[SDE_table_registry] ([registration_id])
GO
ALTER TABLE [dbo].[SDE_archives] CHECK CONSTRAINT [archives_fk1]
GO
/****** Object:  ForeignKey [archives_fk2]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_archives]  WITH CHECK ADD  CONSTRAINT [archives_fk2] FOREIGN KEY([history_regid])
REFERENCES [dbo].[SDE_table_registry] ([registration_id])
GO
ALTER TABLE [dbo].[SDE_archives] CHECK CONSTRAINT [archives_fk2]
GO
/****** Object:  ForeignKey [colregistry_fk]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_column_registry]  WITH NOCHECK ADD  CONSTRAINT [colregistry_fk] FOREIGN KEY([table_name], [owner], [database_name])
REFERENCES [dbo].[SDE_table_registry] ([table_name], [owner], [database_name])
ON UPDATE CASCADE
ON DELETE CASCADE
GO
ALTER TABLE [dbo].[SDE_column_registry] CHECK CONSTRAINT [colregistry_fk]
GO
/****** Object:  ForeignKey [geocol_fk]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_geometry_columns]  WITH NOCHECK ADD  CONSTRAINT [geocol_fk] FOREIGN KEY([srid])
REFERENCES [dbo].[SDE_spatial_references] ([srid])
GO
ALTER TABLE [dbo].[SDE_geometry_columns] CHECK CONSTRAINT [geocol_fk]
GO
/****** Object:  ForeignKey [rascol_fk]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_raster_columns]  WITH NOCHECK ADD  CONSTRAINT [rascol_fk] FOREIGN KEY([srid])
REFERENCES [dbo].[SDE_spatial_references] ([srid])
GO
ALTER TABLE [dbo].[SDE_raster_columns] CHECK CONSTRAINT [rascol_fk]
GO
/****** Object:  ForeignKey [mvtables_modified_fk1]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_mvtables_modified]  WITH CHECK ADD  CONSTRAINT [mvtables_modified_fk1] FOREIGN KEY([state_id])
REFERENCES [dbo].[SDE_states] ([state_id])
GO
ALTER TABLE [dbo].[SDE_mvtables_modified] CHECK CONSTRAINT [mvtables_modified_fk1]
GO
/****** Object:  ForeignKey [mvtables_modified_fk2]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_mvtables_modified]  WITH CHECK ADD  CONSTRAINT [mvtables_modified_fk2] FOREIGN KEY([registration_id])
REFERENCES [dbo].[SDE_table_registry] ([registration_id])
GO
ALTER TABLE [dbo].[SDE_mvtables_modified] CHECK CONSTRAINT [mvtables_modified_fk2]
GO
/****** Object:  ForeignKey [sdelayer_stats_fk1]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_layer_stats]  WITH CHECK ADD  CONSTRAINT [sdelayer_stats_fk1] FOREIGN KEY([layer_id])
REFERENCES [dbo].[SDE_layers] ([layer_id])
ON DELETE CASCADE
GO
ALTER TABLE [dbo].[SDE_layer_stats] CHECK CONSTRAINT [sdelayer_stats_fk1]
GO
/****** Object:  ForeignKey [sdelayer_stats_fk2]    Script Date: 03/19/2014 09:13:55 ******/
ALTER TABLE [dbo].[SDE_layer_stats]  WITH CHECK ADD  CONSTRAINT [sdelayer_stats_fk2] FOREIGN KEY([version_id])
REFERENCES [dbo].[SDE_versions] ([version_id])
ON DELETE CASCADE
GO
ALTER TABLE [dbo].[SDE_layer_stats] CHECK CONSTRAINT [sdelayer_stats_fk2]
GO
INSERT INTO T_SYS_DB_INFO (V_ITEM, V_VALUE,V_MEMO) VALUES ('VERSION', '13','数据库版本');
INSERT INTO T_SYS_DB_INFO (V_ITEM, V_VALUE,V_MEMO) VALUES ('VDATE', '2014-09-16','版本日期');
INSERT INTO T_SYS_DB_INFO (V_ITEM, V_VALUE,V_MEMO) VALUES ('PRODUCER', '1','生产者');
INSERT INTO T_SYS_DB_INFO (V_ITEM, V_VALUE,V_MEMO) VALUES ('PRDATE', '','生产日期');
INSERT INTO T_SYS_DB_INFO (V_ITEM, V_VALUE,V_MEMO) VALUES ('NAUPDATE', '','是否已自然更新');
INSERT INTO T_SYS_DB_INFO (V_ITEM, V_VALUE,V_MEMO) VALUES ('NADATE', '','自然更新日期');
INSERT INTO T_SYS_DB_INFO (V_ITEM, V_VALUE,V_MEMO) VALUES ('NGXEDITE', '','是否完成了年度编辑');
GO